var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Bonsai","text":"Bonsai <p>Each of us would have encountered decision trees and rule engines of various kinds in our software journeys. Rule engines are typically structured as a set of rules that are evaluated against a Context. Bonsai is a data structure that models such engines as a tree of knots and edges. The kicker here is that the tree can be recursively nested, allowing you to represent really complex rules as simple nested forest of trees.</p>"},{"location":"index.html#what-is-bonsai","title":"What is Bonsai?","text":"<p>Bonsai is a decision forest. It is Java Library for data selection based on conditions. It enables you to:</p> <ol> <li>Create a forest of trees with key-to-data mappings</li> <li>Build complex decision trees with conditional branching</li> <li>Represent nested, hierarchical rule structures</li> <li>Evaluate rules against a context to traverse the tree and select the right data element. The Context and Rules are    represented by a combination of JsonPath    and Query-DSL</li> <li>Modify trees dynamically with delta operations</li> <li>Maintain versioning of tree components</li> <li>Plug any storage implementations</li> </ol>"},{"location":"index.html#why-bonsai","title":"Why Bonsai?","text":"<p>While there are several rule engine options out there, none bridge the gap between data selection and rule definition in a nice way. They are either too heavy or are workflow systems being termed as rule engines.</p> <p>Consider a scenario where data elements are configurations, and different variations of these configurations are to be selected based on a set of conditions. What started off as a small rule engine for Frontend App configurations, Bonsai as a library powers a large number of use-cases internally in PhonePe. It is either used  directly as a light-weight library, or wrapped in a service that provides a UI to create and manage trees. One such prominent service is an internal feature flagging and configuration system, which powers the page structure, and launch / placement of most widgets on the PhonePe app.</p>"},{"location":"index.html#visual-representation","title":"Visual Representation","text":"<p>Note</p> <p>The above image is just a manually created representation, not to be confused with any UI kit, this library does not come with one.</p>"},{"location":"index.html#license","title":"License","text":"<p>Bonsai is licensed under the Apache License 2.0. See the LICENSE file for details.</p>"},{"location":"overview.html","title":"Overview","text":"<p>Bonsai facilitates data selection over on conditions. Conditions are represented as tree-based rule engines that enables developers to create complex decision trees with conditional branching and nested, hierarchical rule structures.</p>"},{"location":"overview.html#key-features","title":"Key Features","text":"<ul> <li>Tree-Based Structure: Represent your rules as a tree of knots and edges</li> <li>Recursive Nesting: Create complex, nested rule structures</li> <li>Conditional Branching: Define conditions for traversing different paths in the tree</li> <li>Context-Based Evaluation: Evaluate rules against a context to select the appropriate data</li> <li>Dynamic Modifications: Modify trees at runtime with delta operations</li> <li>Versioning Support: Track changes to tree components</li> <li>Pluggable Storage: Use any storage implementation for persistence</li> <li>Performance Optimized: Designed for high-performance rule evaluation</li> </ul>"},{"location":"overview.html#architecture","title":"Architecture","text":"<p>Bonsai is built around a tree data structure where:</p> <ul> <li>Knots are the nodes in the tree, containing data or references to other knots</li> <li>Edges (or Variations) connect knots and define conditional paths through the tree</li> <li>KnotData represents the content stored within a knot (values, lists, or maps)</li> <li>Context is the evaluation entity against which the tree is traversed</li> </ul> <p>This architecture allows for a flexible and powerful rule engine that can represent complex decision logic in a structured and maintainable way.</p>"},{"location":"overview.html#use-cases","title":"Use Cases","text":"<p>Bonsai is particularly well-suited for scenarios where:</p> <ul> <li>You need to select different data based on complex conditions</li> <li>Rules need to be dynamically updated without code changes</li> <li>Decision logic is hierarchical or nested</li> <li>You want to maintain versioning of rule changes</li> <li>Performance is critical for rule evaluation</li> </ul> <p>Some common use cases include:</p> <ul> <li>Feature flagging systems</li> <li>Dynamic pricing rules</li> <li>Content personalization</li> <li>Configuration management</li> <li>Eligibility determination</li> <li>Workflow routing</li> </ul>"},{"location":"overview.html#benefits","title":"Benefits","text":"<ul> <li>Flexibility: Represent complex rules in a structured way</li> <li>Maintainability: Separate rule logic from application code</li> <li>Scalability: Handle large rule sets efficiently</li> <li>Versioning: Track changes to rules over time</li> <li>Performance: Optimize rule evaluation for high-throughput scenarios</li> <li>Extensibility: Plug in custom storage implementations</li> </ul>"},{"location":"storage.html","title":"Storage","text":"<p>Bonsai is designed with a flexible storage architecture that allows you to use different storage implementations for different environments and use cases. This page explains the storage options available and provides guidance on implementing custom storage solutions.</p>"},{"location":"storage.html#storage-architecture","title":"Storage Architecture","text":"<p>Bonsai requires three storage components:</p> <ol> <li>KnotStore: Responsible for storing and retrieving Knots</li> <li>EdgeStore: Responsible for storing and retrieving Edges</li> <li>KeyTreeStore: Responsible for storing and retrieving mappings between keys and root Knots</li> </ol> <p>These components are defined as interfaces, allowing you to provide custom implementations for each.</p>"},{"location":"storage.html#default-in-memory-storage","title":"Default In-Memory Storage","text":"<p>Out of the box, Bonsai provides in-memory storage implementations:</p> <ul> <li>InMemoryKnotStore: Stores Knots in memory using a ConcurrentHashMap</li> <li>InMemoryEdgeStore: Stores Edges in memory using a ConcurrentHashMap</li> <li>InMemoryKeyTreeStore: Stores key-to-Knot mappings in memory using a ConcurrentHashMap</li> </ul> <p>These implementations are suitable for development, testing, and small-scale applications, but they do not provide persistence across application restarts.</p>"},{"location":"storage.html#custom-storage-implementations","title":"Custom Storage Implementations","text":"<p>For production use, you'll likely want to implement custom storage backends that provide persistence. Here are some common approaches:</p>"},{"location":"storage.html#redis-based-storage","title":"Redis-Based Storage","text":"<p>Redis is a popular choice for Bonsai storage due to its performance and data structure support:</p> <pre><code>public class RedisKnotStore implements KnotStore {\n    private final RedisClient redisClient;\n    private final ObjectMapper objectMapper;\n\n    public RedisKnotStore(RedisClient redisClient) {\n        this.redisClient = redisClient;\n        this.objectMapper = new ObjectMapper();\n    }\n\n    @Override\n    public Knot getKnot(String knotId) {\n        String json = redisClient.get(\"knot:\" + knotId);\n        if (json == null) {\n            return null;\n        }\n        try {\n            return objectMapper.readValue(json, Knot.class);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to deserialize knot\", e);\n        }\n    }\n\n    @Override\n    public void putKnot(Knot knot) {\n        try {\n            String json = objectMapper.writeValueAsString(knot);\n            redisClient.set(\"knot:\" + knot.getId(), json);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to serialize knot\", e);\n        }\n    }\n\n    // Implement other methods...\n}\n</code></pre>"},{"location":"storage.html#database-based-storage","title":"Database-Based Storage","text":"<p>Relational or NoSQL databases can also be used for Bonsai storage:</p> <pre><code>public class JdbcKnotStore implements KnotStore {\n    private final DataSource dataSource;\n    private final ObjectMapper objectMapper;\n\n    public JdbcKnotStore(DataSource dataSource) {\n        this.dataSource = dataSource;\n        this.objectMapper = new ObjectMapper();\n    }\n\n    @Override\n    public Knot getKnot(String knotId) {\n        try (Connection conn = dataSource.getConnection();\n             PreparedStatement stmt = conn.prepareStatement(\"SELECT data FROM knots WHERE id = ?\")) {\n            stmt.setString(1, knotId);\n            try (ResultSet rs = stmt.executeQuery()) {\n                if (rs.next()) {\n                    String json = rs.getString(\"data\");\n                    return objectMapper.readValue(json, Knot.class);\n                }\n                return null;\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to retrieve knot\", e);\n        }\n    }\n\n    @Override\n    public void putKnot(Knot knot) {\n        try (Connection conn = dataSource.getConnection();\n             PreparedStatement stmt = conn.prepareStatement(\n                 \"INSERT INTO knots (id, data) VALUES (?, ?) ON DUPLICATE KEY UPDATE data = ?\")) {\n            String json = objectMapper.writeValueAsString(knot);\n            stmt.setString(1, knot.getId());\n            stmt.setString(2, json);\n            stmt.setString(3, json);\n            stmt.executeUpdate();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to store knot\", e);\n        }\n    }\n\n    // Implement other methods...\n}\n</code></pre>"},{"location":"storage.html#separation-of-read-and-write-instances","title":"Separation of Read and Write Instances","text":"<p>For high-performance applications, it's recommended to separate read and write instances:</p> <pre><code>// Read-only instance using in-memory storage\nBonsai&lt;Context&gt; readOnlyBonsai = BonsaiBuilder.builder()\n    .withBonsaiProperties(BonsaiProperties.builder().build())\n    .withEdgeStore(new InMemoryEdgeStore())\n    .withKeyTreeStore(new InMemoryKeyTreeStore())\n    .withKnotStore(new InMemoryKnotStore())\n    .build();\n\n// Write instance using persistent storage\nBonsai&lt;Context&gt; writeOnlyBonsai = BonsaiBuilder.builder()\n    .withBonsaiProperties(BonsaiProperties.builder().build())\n    .withEdgeStore(new RedisEdgeStore(redisClient))\n    .withKeyTreeStore(new RedisKeyTreeStore(redisClient))\n    .withKnotStore(new RedisKnotStore(redisClient))\n    .build();\n</code></pre> <p>This approach allows you to optimize for read performance while ensuring data persistence.</p>"},{"location":"storage.html#caching-strategies","title":"Caching Strategies","text":"<p>For improved performance, you can implement caching in your storage implementations:</p> <pre><code>public class CachedKnotStore implements KnotStore {\n    private final KnotStore delegate;\n    private final Cache&lt;String, Knot&gt; cache;\n\n    public CachedKnotStore(KnotStore delegate, Cache&lt;String, Knot&gt; cache) {\n        this.delegate = delegate;\n        this.cache = cache;\n    }\n\n    @Override\n    public Knot getKnot(String knotId) {\n        Knot knot = cache.get(knotId);\n        if (knot == null) {\n            knot = delegate.getKnot(knotId);\n            if (knot != null) {\n                cache.put(knotId, knot);\n            }\n        }\n        return knot;\n    }\n\n    @Override\n    public void putKnot(Knot knot) {\n        delegate.putKnot(knot);\n        cache.put(knot.getId(), knot);\n    }\n\n    // Implement other methods...\n}\n</code></pre>"},{"location":"storage.html#best-practices","title":"Best Practices","text":"<ul> <li>Choose the right storage for your needs: Consider factors like persistence, performance, and scalability</li> <li>Implement proper error handling: Storage operations should handle errors gracefully</li> <li>Consider caching: Use caching to improve performance for frequently accessed data</li> <li>Ensure thread safety: Storage implementations should be thread-safe</li> <li>Optimize for read performance: Most applications will have more reads than writes</li> <li>Consider versioning: Implement versioning to handle concurrent modifications</li> <li>Test thoroughly: Ensure your storage implementations work correctly under load</li> </ul>"},{"location":"advanced-usage/index.html","title":"Advanced Usage","text":"<p>This section covers advanced usage patterns and techniques for Bonsai. These topics build on the basic concepts and operations covered in the previous sections and provide more sophisticated ways to use Bonsai in your applications.</p>"},{"location":"advanced-usage/index.html#topics-covered","title":"Topics Covered","text":"<ul> <li>Nested Tree Structures: Learn how to create and work with complex nested tree structures</li> <li>Custom Context Implementation: Understand how to create custom Context implementations for specific application needs</li> <li>Tree Validation: Explore techniques for validating tree structures</li> <li>Versioning and Concurrency: Learn how to handle versioning and concurrent modifications</li> <li>Contextual Preferences: Understand how to use contextual preferences to override normal tree traversal</li> </ul>"},{"location":"advanced-usage/index.html#when-to-use-advanced-features","title":"When to Use Advanced Features","text":"<p>The advanced features of Bonsai are designed for scenarios where:</p> <ul> <li>You need to represent complex, hierarchical data structures</li> <li>You have specific requirements for context evaluation</li> <li>You need to ensure the validity of tree structures</li> <li>You need to handle concurrent modifications</li> <li>You want to provide user-specific overrides of default configurations</li> </ul>"},{"location":"advanced-usage/index.html#example-combining-advanced-features","title":"Example: Combining Advanced Features","text":"<p>Here's an example that combines several advanced features:</p> <pre><code>// Create a custom context implementation\npublic class UserContext extends Context {\n    private User user;\n\n    public UserContext(User user) {\n        super(JsonPath.parse(user));\n        this.user = user;\n    }\n\n    // Custom methods to access user data\n    public int getUserAge() {\n        return user.getAge();\n    }\n\n    public String getUserCountry() {\n        return user.getCountry();\n    }\n}\n\n// Create a validator\nBonsaiTreeValidator validator = new ComponentBonsaiTreeValidator();\n\n// Get a tree structure\nTreeKnot tree = bonsai.getCompleteTree(\"userEligibility\");\n\n// Validate the tree structure\nValidationResult result = validator.validate(tree);\nif (!result.isValid()) {\n    // Handle validation errors\n    List&lt;ValidationError&gt; errors = result.getErrors();\n    for (ValidationError error : errors) {\n        System.err.println(error.getMessage());\n    }\n}\n\n// Create a context with preferences\nUser user = new User(\"John\", 25, \"US\", \"premium\");\nMap&lt;String, Knot&gt; preferences = preferenceStore.get(user.getId());\nUserContext context = new UserContext(user);\ncontext.setPreferences(preferences);\n\n// Evaluate the tree with versioning\ntry {\n    KeyNode result = bonsai.evaluate(\"userEligibility\", context);\n    // Process the result\n} catch (BonsaiError e) {\n    if (e.getErrorCode() == BonsaiErrorCode.VERSION_MISMATCH) {\n        // Handle version mismatch error\n        System.err.println(\"Version mismatch: \" + e.getMessage());\n    } else {\n        // Handle other errors\n        throw e;\n    }\n}\n</code></pre>"},{"location":"advanced-usage/index.html#best-practices","title":"Best Practices","text":"<ul> <li>Start simple: Begin with basic usage patterns and introduce advanced features as needed</li> <li>Document your approach: Document how you're using advanced features to make your code easier to understand and maintain</li> <li>Test thoroughly: Advanced features often require more thorough testing to ensure they work as expected</li> <li>Consider performance implications: Some advanced features may have performance implications, so test and optimize as needed</li> <li>Use versioning consistently: If you're using versioning, use it consistently across all operations</li> </ul>"},{"location":"advanced-usage/contextual-preferences.html","title":"Contextual Preferences","text":"<p>Contextual preferences in Bonsai allow you to override the normal tree traversal for specific keys. This is a powerful feature that enables user-specific customizations and overrides of default configurations.</p>"},{"location":"advanced-usage/contextual-preferences.html#understanding-contextual-preferences","title":"Understanding Contextual Preferences","text":"<p>The Context class in Bonsai includes a <code>preferences</code> map, which maps keys to specific Knots. When evaluating a key, if the key is found in the preferences map, Bonsai will return the associated Knot directly, bypassing the normal tree traversal.</p> <p>This allows you to provide user-specific overrides of default configurations without modifying the tree structure.</p>"},{"location":"advanced-usage/contextual-preferences.html#creating-a-context-with-preferences","title":"Creating a Context with Preferences","text":"<p>You can create a Context with preferences using the builder pattern:</p> <pre><code>// Create a custom Knot for a specific user\nKnot customHomePageKnot = bonsai.createKnot(\n    ValuedKnotData.builder().jsonValue(\"{\\\"theme\\\":\\\"dark\\\",\\\"layout\\\":\\\"compact\\\"}\").build(),\n    Map.of(\"description\", \"Custom home page configuration for user 123\")\n);\n\n// Create a context with preferences\nMap&lt;String, Knot&gt; preferences = Map.of(\"homePage\", customHomePageKnot);\nContext context = Context.builder()\n    .documentContext(JsonPath.parse(userData))\n    .preferences(preferences)\n    .build();\n\n// Evaluate the tree - will return the custom Knot directly\nKeyNode result = bonsai.evaluate(\"homePage\", context);\n</code></pre> <p>In this example, when evaluating the \"homePage\" key, Bonsai will return the customHomePageKnot directly, without traversing the tree.</p>"},{"location":"advanced-usage/contextual-preferences.html#use-cases-for-contextual-preferences","title":"Use Cases for Contextual Preferences","text":"<p>Contextual preferences are useful in several scenarios:</p>"},{"location":"advanced-usage/contextual-preferences.html#user-specific-configurations","title":"User-Specific Configurations","text":"<p>Allow users to customize their experience by overriding default configurations:</p> <pre><code>// Get user preferences from a database\nMap&lt;String, Knot&gt; userPreferences = userPreferenceService.getPreferences(userId);\n\n// Create a context with user preferences\nContext context = Context.builder()\n    .documentContext(JsonPath.parse(userData))\n    .preferences(userPreferences)\n    .build();\n\n// Evaluate the tree with user preferences\nKeyNode result = bonsai.evaluate(\"userInterface\", context);\n</code></pre>"},{"location":"advanced-usage/contextual-preferences.html#ab-testing","title":"A/B Testing","text":"<p>Assign users to different test groups and override configurations accordingly:</p> <pre><code>// Determine which test group the user belongs to\nString testGroup = abTestingService.getUserTestGroup(userId);\n\n// Get the test configuration for the user's test group\nKnot testConfigKnot = abTestingService.getTestConfiguration(testGroup);\n\n// Create a context with test preferences\nMap&lt;String, Knot&gt; preferences = Map.of(\"featureConfig\", testConfigKnot);\nContext context = Context.builder()\n    .documentContext(JsonPath.parse(userData))\n    .preferences(preferences)\n    .build();\n\n// Evaluate the tree with test preferences\nKeyNode result = bonsai.evaluate(\"featureConfig\", context);\n</code></pre>"},{"location":"advanced-usage/contextual-preferences.html#feature-flags","title":"Feature Flags","text":"<p>Override feature flags for specific users or environments:</p> <pre><code>// Determine which features are enabled for the user\nMap&lt;String, Knot&gt; featureFlags = featureFlagService.getUserFeatureFlags(userId);\n\n// Create a context with feature flags\nContext context = Context.builder()\n    .documentContext(JsonPath.parse(userData))\n    .preferences(featureFlags)\n    .build();\n\n// Evaluate the tree with feature flags\nKeyNode result = bonsai.evaluate(\"features.newUI\", context);\n</code></pre>"},{"location":"advanced-usage/contextual-preferences.html#debugging-and-testing","title":"Debugging and Testing","text":"<p>Override configurations for debugging or testing purposes:</p> <pre><code>// Create a debug configuration\nKnot debugConfigKnot = bonsai.createKnot(\n    ValuedKnotData.builder().jsonValue(\"{\\\"logLevel\\\":\\\"debug\\\",\\\"traceEnabled\\\":true}\").build(),\n    Map.of(\"description\", \"Debug configuration\")\n);\n\n// Create a context with debug preferences\nMap&lt;String, Knot&gt; preferences = Map.of(\"appConfig\", debugConfigKnot);\nContext context = Context.builder()\n    .documentContext(JsonPath.parse(appData))\n    .preferences(preferences)\n    .build();\n\n// Evaluate the tree with debug preferences\nKeyNode result = bonsai.evaluate(\"appConfig\", context);\n</code></pre>"},{"location":"advanced-usage/contextual-preferences.html#managing-preferences","title":"Managing Preferences","text":"<p>In a real application, you would typically store preferences in a database and load them when creating the Context:</p> <pre><code>@Service\npublic class PreferenceService {\n    private final Bonsai&lt;Context&gt; bonsai;\n    private final PreferenceRepository preferenceRepository;\n\n    @Autowired\n    public PreferenceService(Bonsai&lt;Context&gt; bonsai, PreferenceRepository preferenceRepository) {\n        this.bonsai = bonsai;\n        this.preferenceRepository = preferenceRepository;\n    }\n\n    public Map&lt;String, Knot&gt; getUserPreferences(String userId) {\n        // Load user preferences from the database\n        List&lt;Preference&gt; preferences = preferenceRepository.findByUserId(userId);\n\n        // Convert preferences to a map of keys to Knots\n        Map&lt;String, Knot&gt; preferenceMap = new HashMap&lt;&gt;();\n        for (Preference preference : preferences) {\n            // Get or create the Knot for the preference\n            Knot knot = getOrCreateKnot(preference);\n            preferenceMap.put(preference.getKey(), knot);\n        }\n\n        return preferenceMap;\n    }\n\n    private Knot getOrCreateKnot(Preference preference) {\n        // Check if the Knot already exists\n        if (preference.getKnotId() != null) {\n            return bonsai.getKnot(preference.getKnotId());\n        }\n\n        // Create a new Knot for the preference\n        KnotData knotData = createKnotData(preference);\n        Knot knot = bonsai.createKnot(knotData, Map.of(\"description\", \"User preference\"));\n\n        // Update the preference with the new Knot ID\n        preference.setKnotId(knot.getId());\n        preferenceRepository.save(preference);\n\n        return knot;\n    }\n\n    private KnotData createKnotData(Preference preference) {\n        // Create KnotData based on the preference type\n        switch (preference.getType()) {\n            case STRING:\n                return ValuedKnotData.builder().stringValue(preference.getStringValue()).build();\n            case BOOLEAN:\n                return ValuedKnotData.builder().booleanValue(preference.getBooleanValue()).build();\n            case NUMBER:\n                return ValuedKnotData.builder().numberValue(preference.getNumberValue()).build();\n            case JSON:\n                return ValuedKnotData.builder().jsonValue(preference.getJsonValue()).build();\n            default:\n                throw new IllegalArgumentException(\"Unsupported preference type: \" + preference.getType());\n        }\n    }\n}\n</code></pre>"},{"location":"advanced-usage/contextual-preferences.html#custom-context-with-preference-management","title":"Custom Context with Preference Management","text":"<p>You can create a custom Context class that includes methods for managing preferences:</p> <pre><code>public class UserContext extends Context {\n    private final String userId;\n    private final PreferenceService preferenceService;\n\n    public UserContext(String userId, Object data, PreferenceService preferenceService) {\n        super(JsonPath.parse(data), preferenceService.getUserPreferences(userId));\n        this.userId = userId;\n        this.preferenceService = preferenceService;\n    }\n\n    public void addPreference(String key, Knot knot) {\n        getPreferences().put(key, knot);\n        preferenceService.savePreference(userId, key, knot);\n    }\n\n    public void removePreference(String key) {\n        getPreferences().remove(key);\n        preferenceService.deletePreference(userId, key);\n    }\n\n    public boolean hasPreference(String key) {\n        return getPreferences().containsKey(key);\n    }\n}\n</code></pre>"},{"location":"advanced-usage/contextual-preferences.html#best-practices","title":"Best Practices","text":"<ul> <li>Use preferences judiciously: Overriding the normal tree traversal should be done for specific use cases, not as a general approach</li> <li>Document preference keys: Document the keys that can be overridden with preferences</li> <li>Consider performance implications: Loading preferences from a database can impact performance</li> <li>Implement caching: Cache preferences to improve performance</li> <li>Validate preferences: Ensure that preferences are valid before using them</li> <li>Consider security implications: Ensure that users can only override preferences they are allowed to</li> <li>Test with and without preferences: Test your application both with and without preferences to ensure it works correctly in all scenarios</li> </ul>"},{"location":"advanced-usage/custom-context.html","title":"Custom Context Implementation","text":"<p>The Context class in Bonsai is designed to be extensible, allowing you to create custom implementations for specific application needs. This guide explains how to create and use custom Context implementations.</p>"},{"location":"advanced-usage/custom-context.html#why-create-a-custom-context","title":"Why Create a Custom Context?","text":"<p>There are several reasons to create a custom Context implementation:</p> <ul> <li>Add application-specific data: Include additional data that's relevant to your application</li> <li>Provide convenience methods: Add methods that make it easier to access specific data</li> <li>Implement custom evaluation logic: Override the default evaluation behavior</li> <li>Optimize for specific use cases: Tailor the Context to your specific needs</li> <li>Encapsulate business logic: Keep business logic related to context evaluation in one place</li> </ul>"},{"location":"advanced-usage/custom-context.html#basic-custom-context","title":"Basic Custom Context","text":"<p>Here's a simple example of a custom Context implementation:</p> <pre><code>public class UserContext extends Context {\n    private User user;\n\n    public UserContext(User user) {\n        // Initialize the base Context with a JsonPath DocumentContext\n        super(JsonPath.parse(user));\n        this.user = user;\n    }\n\n    // Convenience methods to access user data\n    public int getUserAge() {\n        return user.getAge();\n    }\n\n    public String getUserCountry() {\n        return user.getCountry();\n    }\n\n    public String getUserType() {\n        return user.getType();\n    }\n}\n</code></pre> <p>This custom Context provides convenience methods to access user data directly, without having to use JsonPath expressions.</p>"},{"location":"advanced-usage/custom-context.html#using-a-custom-context","title":"Using a Custom Context","text":"<p>To use a custom Context, you create an instance of it and pass it to the <code>evaluate</code> method:</p> <pre><code>// Create a user object\nUser user = new User(\"John\", 25, \"US\", \"premium\");\n\n// Create a custom context\nUserContext context = new UserContext(user);\n\n// Evaluate the tree with the custom context\nKeyNode result = bonsai.evaluate(\"userEligibility\", context);\n</code></pre>"},{"location":"advanced-usage/custom-context.html#advanced-custom-context","title":"Advanced Custom Context","text":"<p>For more advanced use cases, you can override additional methods or add more functionality:</p> <pre><code>public class EnhancedUserContext extends Context {\n    private User user;\n    private Map&lt;String, Object&gt; additionalData;\n    private Logger logger;\n\n    public EnhancedUserContext(User user, Map&lt;String, Object&gt; additionalData) {\n        super(JsonPath.parse(user));\n        this.user = user;\n        this.additionalData = additionalData;\n        this.logger = LoggerFactory.getLogger(EnhancedUserContext.class);\n    }\n\n    // Override the read method to add logging\n    @Override\n    public &lt;T&gt; T read(String path) {\n        logger.debug(\"Reading path: {}\", path);\n        T result = super.read(path);\n        logger.debug(\"Result: {}\", result);\n        return result;\n    }\n\n    // Add a method to access additional data\n    public Object getAdditionalData(String key) {\n        return additionalData.get(key);\n    }\n\n    // Add a method to check if the user is eligible for a feature\n    public boolean isEligibleForFeature(String featureId) {\n        // Implement custom eligibility logic\n        if (\"premium-feature\".equals(featureId)) {\n            return \"premium\".equals(user.getType()) &amp;&amp; user.getAge() &gt;= 18;\n        }\n        return false;\n    }\n}\n</code></pre> <p>This enhanced Context adds logging, access to additional data, and custom eligibility logic.</p>"},{"location":"advanced-usage/custom-context.html#context-with-custom-evaluation-logic","title":"Context with Custom Evaluation Logic","text":"<p>You can also create a Context that implements custom evaluation logic:</p> <pre><code>public class CustomEvaluationContext extends Context {\n    private Map&lt;String, Boolean&gt; featureFlags;\n\n    public CustomEvaluationContext(Object data, Map&lt;String, Boolean&gt; featureFlags) {\n        super(JsonPath.parse(data));\n        this.featureFlags = featureFlags;\n    }\n\n    // Override the evaluate method to check feature flags first\n    @Override\n    public boolean evaluate(Filter filter) {\n        // Check if the filter is for a feature flag\n        if (filter.getPath().startsWith(\"$.features.\")) {\n            String featureId = filter.getPath().substring(\"$.features.\".length());\n            Boolean flagValue = featureFlags.get(featureId);\n            if (flagValue != null) {\n                // If the feature flag is set, use it instead of evaluating the filter\n                return flagValue;\n            }\n        }\n\n        // Fall back to the default evaluation logic\n        return super.evaluate(filter);\n    }\n}\n</code></pre> <p>This Context checks a map of feature flags before falling back to the default evaluation logic.</p>"},{"location":"advanced-usage/custom-context.html#context-with-caching","title":"Context with Caching","text":"<p>For performance-critical applications, you can create a Context that caches evaluation results:</p> <pre><code>public class CachingContext extends Context {\n    private Map&lt;String, Object&gt; cache = new HashMap&lt;&gt;();\n\n    public CachingContext(Object data) {\n        super(JsonPath.parse(data));\n    }\n\n    @Override\n    public &lt;T&gt; T read(String path) {\n        // Check if the result is already in the cache\n        if (cache.containsKey(path)) {\n            @SuppressWarnings(\"unchecked\")\n            T result = (T) cache.get(path);\n            return result;\n        }\n\n        // If not, read it and cache the result\n        T result = super.read(path);\n        cache.put(path, result);\n        return result;\n    }\n\n    // Add a method to clear the cache\n    public void clearCache() {\n        cache.clear();\n    }\n}\n</code></pre> <p>This Context caches the results of JsonPath expressions to avoid re-evaluating them.</p>"},{"location":"advanced-usage/custom-context.html#context-with-preferences","title":"Context with Preferences","text":"<p>The Context class supports preferences, which allow you to override the normal tree traversal:</p> <pre><code>public class PreferencesContext extends Context {\n    public PreferencesContext(Object data, Map&lt;String, Knot&gt; preferences) {\n        super(JsonPath.parse(data), preferences);\n    }\n\n    // Add a method to add a preference\n    public void addPreference(String key, Knot knot) {\n        getPreferences().put(key, knot);\n    }\n\n    // Add a method to remove a preference\n    public void removePreference(String key) {\n        getPreferences().remove(key);\n    }\n\n    // Add a method to check if a preference exists\n    public boolean hasPreference(String key) {\n        return getPreferences().containsKey(key);\n    }\n}\n</code></pre> <p>This Context adds methods to manage preferences.</p>"},{"location":"advanced-usage/custom-context.html#best-practices","title":"Best Practices","text":"<ul> <li>Keep it simple: Start with a simple custom Context and add complexity as needed</li> <li>Focus on your use case: Tailor your Context to your specific application needs</li> <li>Document your Context: Document the expected data structure and behavior</li> <li>Test thoroughly: Test your custom Context with various inputs and edge cases</li> <li>Consider performance: Be mindful of the performance implications of your custom logic</li> <li>Use inheritance wisely: Create a hierarchy of Context classes if it makes sense for your application</li> <li>Be consistent: Use a consistent approach across your application</li> </ul>"},{"location":"advanced-usage/nested-tree-structures.html","title":"Nested Tree Structures","text":"<p>One of the most powerful features of Bonsai is the ability to create complex nested tree structures. This allows you to represent hierarchical data and complex decision logic in a structured and maintainable way.</p>"},{"location":"advanced-usage/nested-tree-structures.html#understanding-nested-structures","title":"Understanding Nested Structures","text":"<p>Bonsai supports nested structures through two types of KnotData:</p> <ol> <li>MapKnotData: Contains a map of string keys to other Knot references</li> <li>MultiKnotData: Contains a list of keys that reference other Knots</li> </ol> <p>These allow you to create trees where Knots can contain references to other Knots, enabling complex hierarchical structures.</p>"},{"location":"advanced-usage/nested-tree-structures.html#creating-nested-map-structures","title":"Creating Nested Map Structures","text":"<p>Here's an example of creating a nested map structure:</p> <pre><code>// Create leaf knots with values\nKnot nameKnot = bonsai.createKnot(\n    ValuedKnotData.builder().stringValue(\"John Doe\").build(),\n    Map.of()\n);\n\nKnot ageKnot = bonsai.createKnot(\n    ValuedKnotData.builder().numberValue(30).build(),\n    Map.of()\n);\n\nKnot activeKnot = bonsai.createKnot(\n    ValuedKnotData.builder().booleanValue(true).build(),\n    Map.of()\n);\n\n// Create a user profile knot that references the leaf knots\nKnot userProfileKnot = bonsai.createKnot(\n    MapKnotData.builder()\n        .keyMapping(Map.of(\n            \"name\", nameKnot.getId(),\n            \"age\", ageKnot.getId(),\n            \"active\", activeKnot.getId()\n        ))\n        .build(),\n    Map.of(\"description\", \"User profile data\")\n);\n\n// Map a key to the user profile knot\nbonsai.createMapping(\"userProfile\", userProfileKnot.getId());\n</code></pre> <p>This creates a structured user profile with name, age, and active status properties.</p>"},{"location":"advanced-usage/nested-tree-structures.html#creating-nested-list-structures","title":"Creating Nested List Structures","text":"<p>Here's an example of creating a nested list structure:</p> <pre><code>// Create item knots with values\nKnot item1Knot = bonsai.createKnot(\n    ValuedKnotData.builder().stringValue(\"Item 1\").build(),\n    Map.of()\n);\n\nKnot item2Knot = bonsai.createKnot(\n    ValuedKnotData.builder().stringValue(\"Item 2\").build(),\n    Map.of()\n);\n\nKnot item3Knot = bonsai.createKnot(\n    ValuedKnotData.builder().stringValue(\"Item 3\").build(),\n    Map.of()\n);\n\n// Create a list knot that references the item knots\nKnot listKnot = bonsai.createKnot(\n    MultiKnotData.builder()\n        .knotIds(List.of(item1Knot.getId(), item2Knot.getId(), item3Knot.getId()))\n        .build(),\n    Map.of(\"description\", \"List of items\")\n);\n\n// Map a key to the list knot\nbonsai.createMapping(\"itemList\", listKnot.getId());\n</code></pre> <p>This creates a list of items that can be accessed as a collection.</p>"},{"location":"advanced-usage/nested-tree-structures.html#combining-map-and-list-structures","title":"Combining Map and List Structures","text":"<p>You can combine map and list structures to create complex nested hierarchies:</p> <pre><code>// Create user profile knots (as shown above)\nKnot userProfile1Knot = createUserProfile(\"John\", 30, true);\nKnot userProfile2Knot = createUserProfile(\"Jane\", 25, true);\nKnot userProfile3Knot = createUserProfile(\"Bob\", 40, false);\n\n// Create a list of user profiles\nKnot userListKnot = bonsai.createKnot(\n    MultiKnotData.builder()\n        .knotIds(List.of(userProfile1Knot.getId(), userProfile2Knot.getId(), userProfile3Knot.getId()))\n        .build(),\n    Map.of(\"description\", \"List of user profiles\")\n);\n\n// Create department knots with user lists\nKnot engineeringKnot = bonsai.createKnot(\n    MapKnotData.builder()\n        .keyMapping(Map.of(\n            \"name\", bonsai.createKnot(ValuedKnotData.builder().stringValue(\"Engineering\").build(), Map.of()).getId(),\n            \"users\", userListKnot.getId()\n        ))\n        .build(),\n    Map.of(\"description\", \"Engineering department\")\n);\n\n// Create a company knot with departments\nKnot companyKnot = bonsai.createKnot(\n    MapKnotData.builder()\n        .keyMapping(Map.of(\n            \"name\", bonsai.createKnot(ValuedKnotData.builder().stringValue(\"Acme Inc.\").build(), Map.of()).getId(),\n            \"departments\", bonsai.createKnot(\n                MultiKnotData.builder()\n                    .knotIds(List.of(engineeringKnot.getId(), marketingKnot.getId()))\n                    .build(),\n                Map.of()\n            ).getId()\n        ))\n        .build(),\n    Map.of(\"description\", \"Company structure\")\n);\n\n// Map a key to the company knot\nbonsai.createMapping(\"company\", companyKnot.getId());\n</code></pre> <p>This creates a complex nested structure representing a company with departments and users.</p>"},{"location":"advanced-usage/nested-tree-structures.html#evaluating-nested-structures","title":"Evaluating Nested Structures","text":"<p>When evaluating nested structures, the result is a KeyNode that reflects the structure of the KnotData:</p> <pre><code>// Evaluate the company structure\nKeyNode companyNode = bonsai.evaluate(\"company\", context);\n\n// Access the company name\nString companyName = companyNode.getKeyNodeMap().get(\"name\").getValue().getStringValue();\n\n// Access the departments\nList&lt;KeyNode&gt; departments = companyNode.getKeyNodeMap().get(\"departments\").getKeyNodeList();\n\n// Access the first department\nKeyNode engineeringDept = departments.get(0);\nString deptName = engineeringDept.getKeyNodeMap().get(\"name\").getValue().getStringValue();\n\n// Access the users in the department\nList&lt;KeyNode&gt; users = engineeringDept.getKeyNodeMap().get(\"users\").getKeyNodeList();\n\n// Access the first user\nKeyNode user = users.get(0);\nString userName = user.getKeyNodeMap().get(\"name\").getValue().getStringValue();\nDouble userAge = user.getKeyNodeMap().get(\"age\").getValue().getNumberValue();\nBoolean userActive = user.getKeyNodeMap().get(\"active\").getValue().getBooleanValue();\n\nSystem.out.println(\"Company: \" + companyName);\nSystem.out.println(\"Department: \" + deptName);\nSystem.out.println(\"User: \" + userName + \", Age: \" + userAge + \", Active: \" + userActive);\n</code></pre>"},{"location":"advanced-usage/nested-tree-structures.html#conditional-nested-structures","title":"Conditional Nested Structures","text":"<p>You can combine nested structures with conditional logic to create dynamic hierarchies:</p> <pre><code>// Create different configuration knots for different user types\nKnot premiumConfigKnot = bonsai.createKnot(\n    MapKnotData.builder()\n        .keyMapping(Map.of(\n            \"theme\", bonsai.createKnot(ValuedKnotData.builder().stringValue(\"premium\").build(), Map.of()).getId(),\n            \"features\", bonsai.createKnot(\n                MultiKnotData.builder()\n                    .knotIds(List.of(feature1Knot.getId(), feature2Knot.getId(), feature3Knot.getId()))\n                    .build(),\n                Map.of()\n            ).getId()\n        ))\n        .build(),\n    Map.of(\"description\", \"Premium user configuration\")\n);\n\nKnot basicConfigKnot = bonsai.createKnot(\n    MapKnotData.builder()\n        .keyMapping(Map.of(\n            \"theme\", bonsai.createKnot(ValuedKnotData.builder().stringValue(\"basic\").build(), Map.of()).getId(),\n            \"features\", bonsai.createKnot(\n                MultiKnotData.builder()\n                    .knotIds(List.of(feature1Knot.getId()))\n                    .build(),\n                Map.of()\n            ).getId()\n        ))\n        .build(),\n    Map.of(\"description\", \"Basic user configuration\")\n);\n\n// Create a root knot with conditional edges\nKnot rootKnot = bonsai.createKnot(\n    ValuedKnotData.builder().build(),\n    Map.of(\"description\", \"User configuration decision point\")\n);\n\n// Add variations to the root knot\nbonsai.addVariation(rootKnot.getId(), Variation.builder()\n    .knotId(premiumConfigKnot.getId())\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.user.type\")\n            .operator(Operator.EQUALS)\n            .value(\"premium\")\n            .build()\n    ))\n    .build());\n\nbonsai.addVariation(rootKnot.getId(), Variation.builder()\n    .knotId(basicConfigKnot.getId())\n    .filters(List.of())\n    .build());\n\n// Map a key to the root knot\nbonsai.createMapping(\"userConfig\", rootKnot.getId());\n</code></pre> <p>This creates a configuration structure that varies based on the user type.</p>"},{"location":"advanced-usage/nested-tree-structures.html#best-practices","title":"Best Practices","text":"<ul> <li>Plan your structure: Design your nested structure before implementing it</li> <li>Keep it shallow: Minimize the depth of your nested structures for better performance</li> <li>Reuse knots: Use the same knot in multiple places to avoid duplication</li> <li>Use meaningful keys: Choose clear and descriptive keys for map entries</li> <li>Consider evaluation performance: Deep nested structures can be expensive to evaluate</li> <li>Document your structure: Document the expected structure to make it easier to understand and maintain</li> <li>Validate your structure: Use the validator to ensure your nested structure is valid</li> </ul>"},{"location":"advanced-usage/tree-validation.html","title":"Tree Validation","text":"<p>Validating tree structures is an important part of ensuring the integrity and correctness of your Bonsai trees. This guide explains how to use Bonsai's validation capabilities to validate tree structures.</p>"},{"location":"advanced-usage/tree-validation.html#why-validate-trees","title":"Why Validate Trees?","text":"<p>There are several reasons to validate tree structures:</p> <ul> <li>Ensure correctness: Verify that the tree structure is valid and follows the expected format</li> <li>Prevent errors: Catch errors before they cause problems at runtime</li> <li>Maintain consistency: Ensure that the tree structure is consistent with your application's expectations</li> <li>Document expectations: Use validation to document the expected structure of your trees</li> <li>Improve reliability: Make your application more reliable by validating inputs</li> </ul>"},{"location":"advanced-usage/tree-validation.html#using-the-bonsaitreevalidator","title":"Using the BonsaiTreeValidator","text":"<p>Bonsai provides a <code>BonsaiTreeValidator</code> interface and a default implementation called <code>ComponentBonsaiTreeValidator</code>:</p> <pre><code>// Create a validator\nBonsaiTreeValidator validator = new ComponentBonsaiTreeValidator();\n\n// Get a tree structure\nTreeKnot tree = bonsai.getCompleteTree(\"userEligibility\");\n\n// Validate the tree structure\nValidationResult result = validator.validate(tree);\n\nif (!result.isValid()) {\n    // Handle validation errors\n    List&lt;ValidationError&gt; errors = result.getErrors();\n    for (ValidationError error : errors) {\n        System.err.println(error.getMessage());\n    }\n}\n</code></pre> <p>The <code>validate</code> method returns a <code>ValidationResult</code> object that contains information about whether the tree is valid and any validation errors that were found.</p>"},{"location":"advanced-usage/tree-validation.html#validation-checks","title":"Validation Checks","text":"<p>The <code>ComponentBonsaiTreeValidator</code> performs several checks on the tree structure:</p> <ul> <li>Cycle detection: Ensures that the tree does not contain cycles</li> <li>Knot existence: Ensures that all referenced Knots exist</li> <li>Edge validity: Ensures that all Edges are valid</li> <li>Filter validity: Ensures that all Filters are valid</li> <li>Property validity: Ensures that all properties are valid</li> </ul>"},{"location":"advanced-usage/tree-validation.html#custom-validation","title":"Custom Validation","text":"<p>You can create a custom validator by implementing the <code>BonsaiTreeValidator</code> interface:</p> <pre><code>public class CustomValidator implements BonsaiTreeValidator {\n    @Override\n    public ValidationResult validate(TreeKnot tree) {\n        List&lt;ValidationError&gt; errors = new ArrayList&lt;&gt;();\n\n        // Perform custom validation checks\n        if (tree.getData() == null) {\n            errors.add(new ValidationError(\"Tree data cannot be null\"));\n        }\n\n        // Check that the tree has at least one edge\n        if (tree.getEdges() == null || tree.getEdges().isEmpty()) {\n            errors.add(new ValidationError(\"Tree must have at least one edge\"));\n        }\n\n        // Check that all edges have valid filters\n        if (tree.getEdges() != null) {\n            for (TreeEdge edge : tree.getEdges()) {\n                if (edge.getFilters() == null) {\n                    errors.add(new ValidationError(\"Edge filters cannot be null\"));\n                }\n            }\n        }\n\n        // Return the validation result\n        return new ValidationResult(errors.isEmpty(), errors);\n    }\n}\n</code></pre> <p>This custom validator performs additional checks beyond what the default validator does.</p>"},{"location":"advanced-usage/tree-validation.html#combining-validators","title":"Combining Validators","text":"<p>You can combine multiple validators to perform a more comprehensive validation:</p> <pre><code>public class CompositeValidator implements BonsaiTreeValidator {\n    private List&lt;BonsaiTreeValidator&gt; validators;\n\n    public CompositeValidator(List&lt;BonsaiTreeValidator&gt; validators) {\n        this.validators = validators;\n    }\n\n    @Override\n    public ValidationResult validate(TreeKnot tree) {\n        List&lt;ValidationError&gt; errors = new ArrayList&lt;&gt;();\n\n        // Run all validators\n        for (BonsaiTreeValidator validator : validators) {\n            ValidationResult result = validator.validate(tree);\n            if (!result.isValid()) {\n                errors.addAll(result.getErrors());\n            }\n        }\n\n        // Return the combined validation result\n        return new ValidationResult(errors.isEmpty(), errors);\n    }\n}\n\n// Create a composite validator\nList&lt;BonsaiTreeValidator&gt; validators = List.of(\n    new ComponentBonsaiTreeValidator(),\n    new CustomValidator(),\n    new AnotherCustomValidator()\n);\nBonsaiTreeValidator compositeValidator = new CompositeValidator(validators);\n\n// Validate the tree structure\nValidationResult result = compositeValidator.validate(tree);\n</code></pre> <p>This allows you to combine the default validator with custom validators to perform a more comprehensive validation.</p>"},{"location":"advanced-usage/tree-validation.html#validating-during-tree-creation","title":"Validating During Tree Creation","text":"<p>You can validate trees during creation to ensure that they are valid before they are used:</p> <pre><code>// Create a tree structure\nTreeKnot tree = TreeKnot.builder()\n    .id(\"rootKnot\")\n    .data(ValuedKnotData.builder().build())\n    .properties(Map.of(\"description\", \"Root knot\"))\n    .edges(List.of(\n        TreeEdge.builder()\n            .id(\"edge1\")\n            .filters(List.of(\n                Filter.builder()\n                    .path(\"$.user.age\")\n                    .operator(Operator.GREATER_THAN_EQUAL)\n                    .value(18)\n                    .build()\n            ))\n            .targetKnot(\n                TreeKnot.builder()\n                    .id(\"eligibleKnot\")\n                    .data(ValuedKnotData.builder().booleanValue(true).build())\n                    .properties(Map.of(\"description\", \"User is eligible\"))\n                    .build()\n            )\n            .build()\n    ))\n    .build();\n\n// Validate the tree structure\nBonsaiTreeValidator validator = new ComponentBonsaiTreeValidator();\nValidationResult result = validator.validate(tree);\n\nif (result.isValid()) {\n    // Create the tree\n    Knot rootKnot = bonsai.createCompleteTree(tree);\n    bonsai.createMapping(\"userEligibility\", rootKnot.getId());\n} else {\n    // Handle validation errors\n    List&lt;ValidationError&gt; errors = result.getErrors();\n    for (ValidationError error : errors) {\n        System.err.println(error.getMessage());\n    }\n}\n</code></pre> <p>This ensures that only valid trees are created.</p>"},{"location":"advanced-usage/tree-validation.html#validating-during-tree-updates","title":"Validating During Tree Updates","text":"<p>You can also validate trees during updates to ensure that they remain valid:</p> <pre><code>// Get the current tree\nTreeKnot tree = bonsai.getCompleteTree(\"userEligibility\");\n\n// Make changes to the tree\n// ...\n\n// Validate the updated tree\nBonsaiTreeValidator validator = new ComponentBonsaiTreeValidator();\nValidationResult result = validator.validate(tree);\n\nif (result.isValid()) {\n    // Apply the changes\n    List&lt;DeltaOperation&gt; operations = createDeltaOperations(tree);\n    bonsai.applyDeltaOperations(\"userEligibility\", operations);\n} else {\n    // Handle validation errors\n    List&lt;ValidationError&gt; errors = result.getErrors();\n    for (ValidationError error : errors) {\n        System.err.println(error.getMessage());\n    }\n}\n</code></pre> <p>This ensures that only valid updates are applied.</p>"},{"location":"advanced-usage/tree-validation.html#validation-in-a-service-layer","title":"Validation in a Service Layer","text":"<p>In a typical application, you might implement validation in a service layer:</p> <pre><code>@Service\npublic class BonsaiService {\n    private final Bonsai&lt;Context&gt; bonsai;\n    private final BonsaiTreeValidator validator;\n\n    @Autowired\n    public BonsaiService(Bonsai&lt;Context&gt; bonsai, BonsaiTreeValidator validator) {\n        this.bonsai = bonsai;\n        this.validator = validator;\n    }\n\n    public Knot createTree(TreeKnot tree, String key) {\n        // Validate the tree\n        ValidationResult result = validator.validate(tree);\n        if (!result.isValid()) {\n            throw new InvalidTreeException(\"Invalid tree structure\", result.getErrors());\n        }\n\n        // Create the tree\n        Knot rootKnot = bonsai.createCompleteTree(tree);\n        bonsai.createMapping(key, rootKnot.getId());\n        return rootKnot;\n    }\n\n    public void updateTree(TreeKnot tree, String key) {\n        // Validate the tree\n        ValidationResult result = validator.validate(tree);\n        if (!result.isValid()) {\n            throw new InvalidTreeException(\"Invalid tree structure\", result.getErrors());\n        }\n\n        // Update the tree\n        List&lt;DeltaOperation&gt; operations = createDeltaOperations(tree);\n        bonsai.applyDeltaOperations(key, operations);\n    }\n}\n</code></pre> <p>This ensures that all trees created or updated through the service are valid.</p>"},{"location":"advanced-usage/tree-validation.html#best-practices","title":"Best Practices","text":"<ul> <li>Validate early: Validate trees as early as possible to catch errors before they cause problems</li> <li>Validate often: Validate trees at key points in your application to ensure they remain valid</li> <li>Use custom validators: Create custom validators for your specific application needs</li> <li>Combine validators: Use multiple validators to perform a more comprehensive validation</li> <li>Document validation rules: Document the validation rules to make them easier to understand and maintain</li> <li>Handle validation errors gracefully: Provide clear error messages and handle validation errors appropriately</li> <li>Test validation: Test your validation logic with various inputs, including edge cases</li> </ul>"},{"location":"advanced-usage/versioning.html","title":"Versioning and Concurrency","text":"<p>Bonsai provides built-in support for versioning of tree components, which helps handle concurrent modifications and maintain data integrity. This guide explains how to use versioning in Bonsai.</p>"},{"location":"advanced-usage/versioning.html#understanding-versioning","title":"Understanding Versioning","text":"<p>Each Knot and Edge in Bonsai has a version number that is automatically incremented when the component is modified. This version number can be used to detect concurrent modifications and prevent data corruption.</p>"},{"location":"advanced-usage/versioning.html#version-checking","title":"Version Checking","text":"<p>When updating a Knot or Edge, you can include the current version number in the properties map to ensure that the component hasn't been modified since you retrieved it:</p> <pre><code>// Get a Knot\nKnot knot = bonsai.getKnot(\"knotId\");\nlong version = knot.getVersion();\n\n// Update the Knot with version check\ntry {\n    Knot oldKnot = bonsai.updateKnotData(\n        \"knotId\",\n        ValuedKnotData.builder().stringValue(\"Updated value\").build(),\n        Map.of(\"description\", \"Updated knot\", \"version\", version)\n    );\n} catch (BonsaiError e) {\n    if (e.getErrorCode() == BonsaiErrorCode.VERSION_MISMATCH) {\n        // Handle version mismatch error\n        System.err.println(\"Knot was modified by another process\");\n    } else {\n        // Handle other errors\n        throw e;\n    }\n}\n</code></pre> <p>If the Knot has been modified since you retrieved it, the <code>updateKnotData</code> method will throw a <code>BonsaiError</code> with the error code <code>VERSION_MISMATCH</code>.</p>"},{"location":"advanced-usage/versioning.html#handling-version-mismatch","title":"Handling Version Mismatch","text":"<p>When a version mismatch occurs, you have several options:</p> <ol> <li>Retry the operation: Retrieve the Knot again and retry the update with the new version</li> <li>Merge the changes: Retrieve the Knot again, merge your changes with the new version, and update with the merged changes</li> <li>Notify the user: Inform the user that the Knot has been modified and ask them to review the changes</li> <li>Force the update: Update the Knot without version checking (not recommended for most cases)</li> </ol> <p>Here's an example of retrying the operation:</p> <pre><code>boolean updated = false;\nint maxRetries = 3;\nint retryCount = 0;\n\nwhile (!updated &amp;&amp; retryCount &lt; maxRetries) {\n    try {\n        // Get the Knot\n        Knot knot = bonsai.getKnot(\"knotId\");\n        long version = knot.getVersion();\n\n        // Update the Knot with version check\n        Knot oldKnot = bonsai.updateKnotData(\n            \"knotId\",\n            ValuedKnotData.builder().stringValue(\"Updated value\").build(),\n            Map.of(\"description\", \"Updated knot\", \"version\", version)\n        );\n\n        // Update successful\n        updated = true;\n    } catch (BonsaiError e) {\n        if (e.getErrorCode() == BonsaiErrorCode.VERSION_MISMATCH) {\n            // Retry\n            retryCount++;\n            if (retryCount &gt;= maxRetries) {\n                System.err.println(\"Failed to update Knot after \" + maxRetries + \" retries\");\n            }\n        } else {\n            // Handle other errors\n            throw e;\n        }\n    }\n}\n</code></pre>"},{"location":"advanced-usage/versioning.html#versioning-in-delta-operations","title":"Versioning in Delta Operations","text":"<p>When using delta operations, you can include version information in the properties map for each operation:</p> <pre><code>// Get the current version of a Knot\nKnot knot = bonsai.getKnot(\"knotId\");\nlong knotVersion = knot.getVersion();\n\n// Get the current version of an Edge\nEdge edge = bonsai.getEdge(\"edgeId\");\nlong edgeVersion = edge.getVersion();\n\n// Create a list of delta operations with version checks\nList&lt;DeltaOperation&gt; operations = new ArrayList&lt;&gt;();\n\n// Update a Knot with version check\noperations.add(DeltaOperation.builder()\n    .operationType(OperationType.UPDATE_KNOT_DATA)\n    .id(\"knotId\")\n    .knotData(ValuedKnotData.builder().stringValue(\"Updated value\").build())\n    .properties(Map.of(\"description\", \"Updated knot\", \"version\", knotVersion))\n    .build());\n\n// Update an Edge with version check\noperations.add(DeltaOperation.builder()\n    .operationType(OperationType.UPDATE_EDGE)\n    .id(\"edgeId\")\n    .sourceKnotId(\"sourceKnotId\")\n    .targetKnotId(\"targetKnotId\")\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.user.age\")\n            .operator(Operator.GREATER_THAN_EQUAL)\n            .value(21)\n            .build()\n    ))\n    .properties(Map.of(\"version\", edgeVersion))\n    .build());\n\n// Apply the delta operations\ntry {\n    TreeKnotState result = bonsai.applyDeltaOperations(\"rootKey\", operations);\n} catch (BonsaiError e) {\n    if (e.getErrorCode() == BonsaiErrorCode.VERSION_MISMATCH) {\n        // Handle version mismatch error\n        System.err.println(\"One or more components were modified by another process\");\n    } else {\n        // Handle other errors\n        throw e;\n    }\n}\n</code></pre> <p>If any of the components have been modified since you retrieved them, the <code>applyDeltaOperations</code> method will throw a <code>BonsaiError</code> with the error code <code>VERSION_MISMATCH</code>.</p>"},{"location":"advanced-usage/versioning.html#optimistic-locking","title":"Optimistic Locking","text":"<p>Bonsai's versioning system implements optimistic locking, which assumes that conflicts are rare and allows multiple processes to read the same data without locking. When a process wants to update the data, it checks that the data hasn't been modified since it was read.</p> <p>This approach has several advantages:</p> <ul> <li>Better performance: No need to acquire and release locks for every operation</li> <li>No deadlocks: Since there are no locks, there's no risk of deadlocks</li> <li>Better scalability: Multiple processes can read the same data concurrently</li> </ul> <p>However, it also has some limitations:</p> <ul> <li>Conflicts can occur: If multiple processes try to update the same data concurrently, some updates may fail</li> <li>Retry logic required: You need to implement retry logic to handle conflicts</li> <li>Not suitable for high-contention scenarios: If conflicts are frequent, optimistic locking may not be the best approach</li> </ul>"},{"location":"advanced-usage/versioning.html#versioning-in-a-service-layer","title":"Versioning in a Service Layer","text":"<p>In a typical application, you might implement versioning in a service layer:</p> <pre><code>@Service\npublic class BonsaiService {\n    private final Bonsai&lt;Context&gt; bonsai;\n\n    @Autowired\n    public BonsaiService(Bonsai&lt;Context&gt; bonsai) {\n        this.bonsai = bonsai;\n    }\n\n    public Knot updateKnot(String knotId, KnotData newData, Map&lt;String, Object&gt; properties) {\n        int maxRetries = 3;\n        int retryCount = 0;\n\n        while (retryCount &lt; maxRetries) {\n            try {\n                // Get the Knot\n                Knot knot = bonsai.getKnot(knotId);\n                long version = knot.getVersion();\n\n                // Add version to properties\n                Map&lt;String, Object&gt; propertiesWithVersion = new HashMap&lt;&gt;(properties);\n                propertiesWithVersion.put(\"version\", version);\n\n                // Update the Knot with version check\n                return bonsai.updateKnotData(knotId, newData, propertiesWithVersion);\n            } catch (BonsaiError e) {\n                if (e.getErrorCode() == BonsaiErrorCode.VERSION_MISMATCH) {\n                    // Retry\n                    retryCount++;\n                    if (retryCount &gt;= maxRetries) {\n                        throw new ConcurrentModificationException(\"Failed to update Knot after \" + maxRetries + \" retries\");\n                    }\n                } else {\n                    // Handle other errors\n                    throw e;\n                }\n            }\n        }\n\n        // This should never happen\n        throw new IllegalStateException(\"Failed to update Knot\");\n    }\n}\n</code></pre> <p>This service method automatically retries the update if a version mismatch occurs, up to a maximum number of retries.</p>"},{"location":"advanced-usage/versioning.html#best-practices","title":"Best Practices","text":"<ul> <li>Always include version information when updating Knots or Edges</li> <li>Implement retry logic to handle version mismatch errors</li> <li>Limit the number of retries to avoid infinite loops</li> <li>Consider using a service layer to encapsulate versioning logic</li> <li>Be mindful of high-contention scenarios where optimistic locking may not be the best approach</li> <li>Document your versioning strategy to make it easier to understand and maintain</li> <li>Test concurrent modifications to ensure your versioning logic works correctly</li> </ul>"},{"location":"core-concepts/index.html","title":"Core Concepts","text":"<p>Understanding concepts that form the foundation of its tree-based rule engine is essential for effectively using Bonsai in your applications.</p>"},{"location":"core-concepts/index.html#key-components","title":"Key Components","text":"<p>Bonsai's architecture revolves around four primary components:</p> <ol> <li>Knot: The fundamental building block of the Bonsai tree structure</li> <li>Edge/Variation: Connections between Knots that define conditional paths</li> <li>KnotData: The content stored within a Knot</li> <li>Context: The evaluation entity against which the tree is traversed</li> </ol> <p>These components work together to create a flexible and powerful rule engine that can represent complex decision logic in a structured and maintainable way.</p>"},{"location":"core-concepts/index.html#how-it-works","title":"How It Works","text":"<p>At a high level, Bonsai operates as follows:</p> <ol> <li>You create a forest of trees with key-to-data mappings</li> <li>Each tree consists of Knots connected by Edges</li> <li>Knots contain data or references to other Knots</li> <li>Edges define conditions for traversing from one Knot to another</li> <li>When evaluating a key, Bonsai traverses the tree based on the provided Context</li> <li>The traversal follows the first Edge whose conditions match the Context</li> <li>The result is the data from the final Knot reached during traversal</li> </ol> <p>This structure allows for complex, nested rule definitions that can be evaluated efficiently against a given context.</p>"},{"location":"core-concepts/index.html#example-scenario","title":"Example Scenario","text":"<p>Consider a simple example of a user eligibility check:</p> <pre><code>Root Knot\n\u251c\u2500\u2500 Edge: If user.age &gt;= 18 AND user.country IN [\"US\", \"CA\", \"UK\"] \u2192 Eligible Knot\n\u2514\u2500\u2500 Edge: If user.age &lt; 18 \u2192 Ineligible Knot\n</code></pre> <p>In this scenario:</p> <ul> <li>The Root Knot is the starting point</li> <li>Two Edges define the conditions for eligibility</li> <li>The Eligible and Ineligible Knots contain the result values (true/false)</li> <li>When evaluating with a Context (e.g., a user with age 25 from the US), Bonsai traverses the tree and returns the appropriate result (eligible: true)</li> </ul>"},{"location":"core-concepts/context.html","title":"Context","text":"<p>Context is the evaluation entity against which the Bonsai tree is traversed. It contains the data needed to evaluate conditions on Edges and determine which paths to follow during tree traversal.</p>"},{"location":"core-concepts/context.html#core-functionality","title":"Core Functionality","text":"<p>The Context serves several key functions in the Bonsai system:</p> <ol> <li>Provides Data for Condition Evaluation: Contains the data that Edge conditions are evaluated against</li> <li>Enables JsonPath Evaluation: Wraps a JsonPath DocumentContext for accessing data using path expressions</li> <li>Supports Contextual Preferences: Can include preferences that override normal tree traversal</li> </ol>"},{"location":"core-concepts/context.html#structure","title":"Structure","text":"<p>At its core, the Context class contains:</p> <pre><code>public class Context {\n    private final DocumentContext documentContext;\n    private final Map&lt;String, Knot&gt; preferences;\n    // ...\n}\n</code></pre> <p>The <code>DocumentContext</code> is a JsonPath object that wraps the data being evaluated. This allows Edge conditions to use JsonPath expressions to access specific parts of the data.</p>"},{"location":"core-concepts/context.html#jsonpath-integration","title":"JsonPath Integration","text":"<p>Bonsai uses JsonPath for evaluating conditions against the Context. JsonPath provides a way to navigate JSON structures using path expressions, similar to how XPath is used for XML.</p> <p>For example, a path expression like <code>$.user.age</code> would access the age property of the user object in the Context data.</p>"},{"location":"core-concepts/context.html#creating-a-context","title":"Creating a Context","text":"<p>There are several ways to create a Context:</p> <pre><code>// Create a Context from a JSON string\nString json = \"{\\\"user\\\": {\\\"age\\\": 25, \\\"country\\\": \\\"US\\\"}}\";\nContext context = Context.builder()\n    .documentContext(JsonPath.parse(json))\n    .build();\n\n// Create a Context from an object\nUser user = new User(\"John\", 25, \"US\");\nContext context = Context.builder()\n    .documentContext(JsonPath.parse(user))\n    .build();\n\n// Create a Context with preferences\nMap&lt;String, Knot&gt; preferences = Map.of(\"homePageConfig\", customKnot);\nContext context = Context.builder()\n    .documentContext(JsonPath.parse(user))\n    .preferences(preferences)\n    .build();\n</code></pre>"},{"location":"core-concepts/context.html#contextual-preferences","title":"Contextual Preferences","text":"<p>The Context can include a <code>preferences</code> map, which maps keys to specific Knots. When evaluating a key, if the key is found in the preferences map, Bonsai will return the associated Knot directly, bypassing the normal tree traversal.</p> <p>This is useful for scenarios like user-specific overrides of default configurations:</p> <pre><code>// Get the current version of a knot\nKnot knot = bonsai.getKnot(\"home_page\");\nMap&lt;String, Knot&gt; preferences = preferenceStore.get(userId); // this storage will have to be implemented by you\nContext context = new Context(JsonPath.parse(userData), preferences); \nbonsai.evaluate(\"home_page\", context);\n</code></pre>"},{"location":"core-concepts/context.html#custom-context-implementation","title":"Custom Context Implementation","text":"<p>You can create custom Context implementations for specific application needs:</p> <pre><code>public class UserContext extends Context {\n    private User user;\n    private Map&lt;String, Object&gt; additionalData;\n\n    // Implement methods to access user data for condition evaluation\n    public int getUserAge() {\n        return user.getAge();\n    }\n\n    public String getUserCountry() {\n        return user.getCountry();\n    }\n}\n</code></pre>"},{"location":"core-concepts/context.html#best-practices","title":"Best Practices","text":"<ul> <li>Structure your Context data in a way that makes JsonPath expressions simple and intuitive</li> <li>Use consistent data structures across similar contexts for easier maintenance</li> <li>Consider performance implications of large Context objects</li> <li>Use preferences judiciously to avoid bypassing the rule engine unnecessarily</li> <li>Document the expected Context structure for each tree to ensure proper usage</li> </ul>"},{"location":"core-concepts/edge.html","title":"Edge/Variation","text":"<p>Edges (also called Variations) are a fundamental component of the Bonsai tree structure. They connect Knots and define conditional paths through the tree, enabling the rule engine's decision-making capabilities.</p>"},{"location":"core-concepts/edge.html#characteristics","title":"Characteristics","text":"<ul> <li>Each Edge has a unique identifier (<code>edgeId</code>)</li> <li>Points to a target Knot</li> <li>Contains a list of conditions/filters that determine when this path should be taken</li> <li>Edges are evaluated in priority order during tree traversal</li> <li>Maintains version information for tracking changes</li> <li>Can have associated properties for metadata</li> </ul>"},{"location":"core-concepts/edge.html#structure","title":"Structure","text":"<p>An Edge typically consists of:</p> <pre><code>public class Edge {\n    private String id;\n    private String knotId;  // Target Knot ID\n    private List&lt;Filter&gt; filters;\n    private long version;\n    private Map&lt;String, Object&gt; properties;\n    // ...\n}\n</code></pre>"},{"location":"core-concepts/edge.html#filtersconditions","title":"Filters/Conditions","text":"<p>Filters (or conditions) define when an Edge should be followed during tree traversal. Each filter consists of:</p> <ul> <li>Path: A JsonPath expression that identifies the data to evaluate in the Context</li> <li>Operator: The comparison operation to perform (equals, greater than, in, etc.)</li> <li>Value: The value to compare against</li> </ul> <p>For example:</p> <pre><code>Filter.builder()\n    .path(\"$.user.age\")\n    .operator(Operator.GREATER_THAN_EQUAL)\n    .value(18)\n    .build()\n</code></pre> <p>This filter checks if the user's age in the Context is greater than or equal to 18.</p>"},{"location":"core-concepts/edge.html#evaluation-order","title":"Evaluation Order","text":"<p>Edges on a Knot are evaluated in the order they are defined. During tree traversal:</p> <ol> <li>Bonsai starts at the root Knot</li> <li>Evaluates each Edge's filters against the Context in order</li> <li>Follows the first Edge whose filters all evaluate to true</li> <li>If no Edge's filters match, the traversal stops at the current Knot</li> </ol> <p>This ordered evaluation allows for fallback logic and default cases.</p>"},{"location":"core-concepts/edge.html#mutual-exclusivity","title":"Mutual Exclusivity","text":"<p>Bonsai can be configured to enforce mutual exclusivity of Edges, meaning that at most one Edge's conditions can match for any given Context. This is controlled by the <code>mutualExclusivitySettingTurnedOn</code> property in <code>BonsaiProperties</code>.</p> <p>When mutual exclusivity is enabled:</p> <ul> <li>Bonsai validates that Edge conditions don't overlap at a level</li> <li>Level is the depth of the tree where the Edge is present</li> <li>Eg: At level 1, the filters for the variation, can only be on a single path (say <code>$.user.location</code> == \"Bangalore\"). At this level   you would not be able to setup another variation with a filter on <code>$.user.gender</code> or any other path. </li> </ul>"},{"location":"core-concepts/edge.html#example","title":"Example","text":"<p>Here's an example of adding an Edge to a Knot:</p> <pre><code>// Add a variation to the root knot\nbonsai.addVariation(rootKnot.getId(), Variation.builder()\n    .knotId(eligibleKnot.getId())\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.user.age\")\n            .operator(Operator.GREATER_THAN_EQUAL)\n            .value(18)\n            .build(),\n        Filter.builder()\n            .path(\"$.user.country\")\n            .operator(Operator.IN)\n            .value(List.of(\"US\", \"CA\", \"UK\"))\n            .build()\n    ))\n    .build());\n</code></pre> <p>This Edge connects the root Knot to the eligible Knot and will be followed if the user is at least 18 years old and from the US, Canada, or the UK.</p>"},{"location":"core-concepts/edge.html#edge-operations","title":"Edge Operations","text":"<p>Bonsai provides several operations for working with Edges:</p> <ul> <li>Create: Create a new Edge between Knots</li> <li>Read: Retrieve an Edge by its ID</li> <li>Update: Modify an Edge's target Knot or filters</li> <li>Delete: Remove an Edge from the tree</li> <li>Unlink: Remove the Edge but keep the target Knot</li> </ul> <p>For more details on these operations, see the Edge Operations page.</p>"},{"location":"core-concepts/edge.html#best-practices","title":"Best Practices","text":"<ul> <li>Order Edges from most specific to most general</li> <li>Use a default Edge (with no filters) as the last Edge on a Knot to handle all remaining cases</li> <li>Keep filter conditions simple and focused</li> <li>Consider the performance impact of complex JsonPath expressions</li> <li>Use meaningful properties to document the purpose of each Edge</li> <li>Be mindful of the maximum number of conditions per Edge (configured in BonsaiProperties)</li> </ul>"},{"location":"core-concepts/knot.html","title":"Knot","text":"<p>A Knot is the fundamental building block of the Bonsai tree structure. It serves as a node in the tree and can contain data or references to other Knots.</p>"},{"location":"core-concepts/knot.html#characteristics","title":"Characteristics","text":"<ul> <li>Each Knot has a unique identifier (<code>knotId</code>)</li> <li>Contains data (<code>KnotData</code>) which can be a value or references to other Knots</li> <li>Has an ordered list of Edges/Variations that define conditional paths to other Knots</li> <li>Maintains version information for tracking changes</li> <li>Can have associated properties for metadata</li> </ul>"},{"location":"core-concepts/knot.html#structure","title":"Structure","text":"<p>A Knot typically consists of:</p> <pre><code>public class Knot {\n    private String id;\n    private KnotData data;\n    private List&lt;Edge&gt; variations;\n    private long version;\n    private Map&lt;String, Object&gt; properties;\n    // ...\n}\n</code></pre>"},{"location":"core-concepts/knot.html#types-of-knots","title":"Types of Knots","text":"<p>Based on the type of data they contain, Knots can be categorized as:</p> <ol> <li>Value Knots: Contain primitive values (string, boolean, number, bytes, JSON)</li> <li>List Knots: Contain references to multiple other Knots</li> <li>Map Knots: Contain key-based references to other Knots</li> </ol>"},{"location":"core-concepts/knot.html#role-in-the-tree","title":"Role in the Tree","text":"<p>Knots serve different roles in the Bonsai tree structure:</p> <ul> <li>Root Knots: Entry points to the tree, typically mapped to keys</li> <li>Decision Knots: Intermediate nodes with multiple outgoing Edges based on conditions</li> <li>Leaf Knots: Terminal nodes containing the actual data values</li> <li>Reference Knots: Nodes that point to other parts of the tree, enabling reuse and complex structures</li> </ul>"},{"location":"core-concepts/knot.html#knot-properties","title":"Knot Properties","text":"<p>Knots can have associated properties that provide metadata or additional information:</p> <ul> <li>Description: Human-readable description of the Knot's purpose</li> <li>Tags: Categorization or grouping information</li> <li>Creation Time: When the Knot was created</li> <li>Last Modified Time: When the Knot was last updated</li> <li>Custom Properties: Any application-specific metadata</li> </ul>"},{"location":"core-concepts/knot.html#example","title":"Example","text":"<p>Here's an example of creating a Knot with a boolean value:</p> <pre><code>// Create a Knot with a boolean value\nKnot eligibleKnot = bonsai.createKnot(\n    ValuedKnotData.builder().booleanValue(true).build(),\n    Map.of(\"description\", \"User is eligible\")\n);\n</code></pre>"},{"location":"core-concepts/knot.html#knot-operations","title":"Knot Operations","text":"<p>Bonsai provides several operations for working with Knots:</p> <ul> <li>Create: Create a new Knot with specified data and properties</li> <li>Read: Retrieve a Knot by its ID</li> <li>Update: Modify a Knot's data or properties</li> <li>Delete: Remove a Knot from the tree</li> <li>Add Variation: Add a new Edge/Variation to a Knot</li> <li>Update Variation: Modify an existing Edge/Variation on a Knot</li> <li>Delete Variation: Remove an Edge/Variation from a Knot</li> </ul> <p>For more details on these operations, see the Knot Operations page.</p>"},{"location":"core-concepts/knot.html#best-practices","title":"Best Practices","text":"<ul> <li>Use meaningful IDs or let Bonsai generate them for you</li> <li>Keep Knot data focused on a single concept or decision point</li> <li>Use properties to add metadata that helps with management and understanding</li> <li>Consider versioning implications when updating Knots</li> <li>Design your tree structure to minimize the depth and complexity</li> </ul>"},{"location":"core-concepts/knotdata.html","title":"KnotData","text":"<p>KnotData represents the content stored within a Knot in the Bonsai tree structure. It defines what information a Knot holds and how it relates to other Knots in the tree.</p>"},{"location":"core-concepts/knotdata.html#types-of-knotdata","title":"Types of KnotData","text":"<p>Bonsai supports three main types of KnotData:</p>"},{"location":"core-concepts/knotdata.html#1-valuedknotdata","title":"1. ValuedKnotData","text":"<p>Contains a primitive value of one of the following types:</p> <ul> <li>String: Text values</li> <li>Boolean: True/false values</li> <li>Number: Numeric values (integers or decimals)</li> <li>Bytes: Binary data</li> <li>JSON: Structured JSON data</li> </ul> <p>Example:</p> <pre><code>// Create a ValuedKnotData with a string value\nValuedKnotData stringData = ValuedKnotData.builder()\n    .stringValue(\"Hello, World!\")\n    .build();\n\n// Create a ValuedKnotData with a boolean value\nValuedKnotData booleanData = ValuedKnotData.builder()\n    .booleanValue(true)\n    .build();\n\n// Create a ValuedKnotData with a number value\nValuedKnotData numberData = ValuedKnotData.builder()\n    .numberValue(42.5)\n    .build();\n\n// Create a ValuedKnotData with JSON value\nValuedKnotData jsonData = ValuedKnotData.builder()\n    .jsonValue(\"{\\\"name\\\":\\\"John\\\",\\\"age\\\":30}\")\n    .build();\n</code></pre>"},{"location":"core-concepts/knotdata.html#2-multiknotdata","title":"2. MultiKnotData","text":"<p>Contains a list of keys that reference other Knots. This enables one-to-many relationships and allows for list-based structures.</p> <p>Example:</p> <pre><code>// Create a MultiKnotData with references to other Knots\nMultiKnotData listData = MultiKnotData.builder()\n    .knotIds(List.of(\"knot1\", \"knot2\", \"knot3\"))\n    .build();\n</code></pre>"},{"location":"core-concepts/knotdata.html#3-mapknotdata","title":"3. MapKnotData","text":"<p>Contains a map of string keys to other Knot references. This enables key-based lookups and allows for structured, nested data.</p> <p>Example:</p> <pre><code>// Create a MapKnotData with key-based references to other Knots\nMapKnotData mapData = MapKnotData.builder()\n    .keyMapping(Map.of(\n        \"user\", userKnot.getId(),\n        \"preferences\", preferencesKnot.getId(),\n        \"history\", historyKnot.getId()\n    ))\n    .build();\n</code></pre>"},{"location":"core-concepts/knotdata.html#usage-patterns","title":"Usage Patterns","text":"<p>Different KnotData types serve different purposes in the Bonsai tree:</p> <ul> <li>ValuedKnotData: Typically used for leaf nodes that contain the actual values or results</li> <li>MultiKnotData: Used when you need to represent a collection or list of related items</li> <li>MapKnotData: Used when you need to represent a structured object with named properties</li> </ul>"},{"location":"core-concepts/knotdata.html#nested-structures","title":"Nested Structures","text":"<p>One of the powerful features of Bonsai is the ability to create nested structures using MapKnotData and MultiKnotData. For example:</p> <pre><code>// Create leaf knots with values\nKnot nameKnot = bonsai.createKnot(\n    ValuedKnotData.builder().stringValue(\"John Doe\").build(),\n    Map.of()\n);\n\nKnot ageKnot = bonsai.createKnot(\n    ValuedKnotData.builder().numberValue(30).build(),\n    Map.of()\n);\n\nKnot activeKnot = bonsai.createKnot(\n    ValuedKnotData.builder().booleanValue(true).build(),\n    Map.of()\n);\n\n// Create a user profile knot that references the leaf knots\nKnot userProfileKnot = bonsai.createKnot(\n    MapKnotData.builder()\n        .keyMapping(Map.of(\n            \"name\", nameKnot.getId(),\n            \"age\", ageKnot.getId(),\n            \"active\", activeKnot.getId()\n        ))\n        .build(),\n    Map.of(\"description\", \"User profile data\")\n);\n</code></pre> <p>This creates a structured user profile with name, age, and active status properties.</p>"},{"location":"core-concepts/knotdata.html#evaluation-results","title":"Evaluation Results","text":"<p>When evaluating a Bonsai tree, the result is a KeyNode that reflects the structure of the KnotData:</p> <ul> <li>For ValuedKnotData, the KeyNode contains the primitive value</li> <li>For MultiKnotData, the KeyNode contains a list of KeyNodes</li> <li>For MapKnotData, the KeyNode contains a map of string keys to KeyNodes</li> </ul> <p>This allows you to access the evaluated data in a structured way that mirrors the original KnotData structure.</p>"},{"location":"core-concepts/knotdata.html#best-practices","title":"Best Practices","text":"<ul> <li>Choose the appropriate KnotData type based on your data structure needs</li> <li>Use ValuedKnotData for simple values and leaf nodes</li> <li>Use MultiKnotData for collections of similar items</li> <li>Use MapKnotData for structured objects with named properties</li> <li>Consider the evaluation performance implications of deeply nested structures</li> <li>Keep your data structures consistent across similar Knots for easier maintenance</li> </ul>"},{"location":"getting-started/getting-started.html","title":"How to read this doc?","text":"<p>To get started with Bonsai, check out the following sections:</p> <p>If you want to do a deeper integration, build applications using the concepts of Bonsai, check out:</p> <ul> <li>Core Concepts - Understand the fundamental building blocks of Bonsai</li> <li>Storage - Learn more about what Bonsai is and how it works</li> </ul> <p>If you are already aware of the concepts, you can directly skip to the following sections:</p> <ul> <li>Usage - See examples of how to use Bonsai in your applications</li> <li>Advanced Usage - Discover advanced features and techniques</li> <li>Performance - Learn about performance considerations and optimizations</li> <li>Use Cases - Explore real-world use cases for Bonsai</li> <li>Troubleshooting - Find solutions to common issues</li> </ul>"},{"location":"getting-started/quick-installation.html","title":"Installation","text":""},{"location":"getting-started/quick-installation.html#maven","title":"Maven","text":"<p>To add Bonsai to your Maven project, include the following dependency in your <code>pom.xml</code> file:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.phonepe.commons&lt;/groupId&gt;\n    &lt;artifactId&gt;bonsai-core&lt;/artifactId&gt;\n    &lt;version&gt;${bonsai.version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Replace <code>${bonsai.version}</code> with the latest version of Bonsai. You can find the latest version on Maven Central.</p>"},{"location":"getting-started/quick-installation.html#gradle","title":"Gradle","text":"<p>To add Bonsai to your Gradle project, include the following dependency in your <code>build.gradle</code> file:</p> <pre><code>implementation 'com.phonepe.commons:bonsai-core:${bonsai.version}'\n</code></pre>"},{"location":"performance/index.html","title":"Performance Considerations","text":"<p>Performance is a critical aspect of any rule engine, and Bonsai is designed with performance in mind. This section covers various performance considerations and optimization techniques for Bonsai.</p>"},{"location":"performance/index.html#topics-covered","title":"Topics Covered","text":"<ul> <li>Optimizing Tree Structure: Learn how to design efficient tree structures</li> <li>Memory and Compute: Understand memory and compute considerations</li> </ul>"},{"location":"performance/index.html#performance-characteristics","title":"Performance Characteristics","text":"<p>Bonsai's performance characteristics depend on several factors:</p> <ul> <li>Tree Depth: The depth of the tree affects traversal time</li> <li>Number of Edges: The number of edges per knot affects evaluation time</li> <li>Filter Complexity: The complexity of filter conditions affects evaluation time</li> <li>Context Size: The size of the context data affects evaluation time</li> <li>Storage Implementation: The performance of the storage implementation affects operation time</li> </ul>"},{"location":"performance/index.html#general-performance-tips","title":"General Performance Tips","text":"<p>Here are some general tips for optimizing Bonsai performance:</p>"},{"location":"performance/index.html#design-efficient-trees","title":"Design Efficient Trees","text":"<ul> <li>Keep trees shallow: Minimize the depth of your trees to reduce traversal time</li> <li>Limit the number of edges: Keep the number of edges per knot reasonable</li> <li>Order edges effectively: Put the most likely matches first to reduce the number of evaluations</li> <li>Use simple filters: Keep filter conditions simple and focused</li> <li>Avoid complex JsonPath expressions: Complex expressions can be expensive to evaluate</li> </ul>"},{"location":"performance/index.html#optimize-storage","title":"Optimize Storage","text":"<ul> <li>Use in-memory storage for read-heavy workloads: In-memory storage provides the best read performance</li> <li>Implement caching: Cache frequently accessed knots and edges</li> <li>Use efficient serialization: Choose an efficient serialization format for persistent storage</li> <li>Consider read/write separation: Use separate instances for read and write operations</li> </ul>"},{"location":"performance/index.html#optimize-context","title":"Optimize Context","text":"<ul> <li>Keep context data small: Include only the necessary data in the context</li> <li>Use custom context implementations: Implement custom context classes for specific use cases</li> <li>Consider caching context evaluation results: Cache the results of expensive evaluations</li> </ul>"},{"location":"performance/index.html#optimize-evaluation","title":"Optimize Evaluation","text":"<ul> <li>Use contextual preferences for frequently accessed keys: Bypass tree traversal for frequently accessed keys</li> <li>Batch evaluations: Evaluate multiple keys in a single operation when possible</li> <li>Implement result caching: Cache evaluation results for frequently used key-context combinations</li> </ul>"},{"location":"performance/index.html#monitoring-and-profiling","title":"Monitoring and Profiling","text":"<p>To identify performance bottlenecks, consider:</p> <ul> <li>Instrumenting your code: Add timing metrics to key operations</li> <li>Using profiling tools: Use profiling tools to identify hotspots</li> <li>Monitoring memory usage: Track memory usage to identify potential issues</li> <li>Logging performance metrics: Log performance metrics for analysis</li> </ul>"},{"location":"performance/index.html#scaling-considerations","title":"Scaling Considerations","text":"<p>For high-throughput applications, consider:</p> <ul> <li>Horizontal scaling: Deploy multiple instances of your application</li> <li>Vertical scaling: Increase the resources available to your application</li> <li>Caching: Implement caching at various levels</li> <li>Asynchronous processing: Use asynchronous processing for non-critical operations</li> </ul>"},{"location":"performance/memory-compute.html","title":"Memory and Compute Considerations","text":"<p>Bonsai's memory usage and computational requirements are important factors to consider when designing and deploying applications that use Bonsai. This guide explains the memory and compute considerations for Bonsai and provides recommendations for optimizing resource usage.</p>"},{"location":"performance/memory-compute.html#memory-usage","title":"Memory Usage","text":"<p>Bonsai's memory usage depends on several factors:</p>"},{"location":"performance/memory-compute.html#tree-size","title":"Tree Size","text":"<p>The size of your tree structure affects memory usage:</p> <ul> <li>Number of Knots: Each Knot requires memory to store its ID, data, properties, and references to Edges</li> <li>Number of Edges: Each Edge requires memory to store its ID, filters, properties, and references to Knots</li> <li>KnotData Size: The size of the data stored in Knots affects memory usage</li> <li>Property Size: The size of properties stored in Knots and Edges affects memory usage</li> </ul> <p>For large trees with thousands of Knots and Edges, memory usage can be significant.</p>"},{"location":"performance/memory-compute.html#storage-implementation","title":"Storage Implementation","text":"<p>The storage implementation affects memory usage:</p> <ul> <li>In-Memory Storage: Stores all Knots and Edges in memory, which provides the best performance but requires more memory</li> <li>Persistent Storage: Stores Knots and Edges in a persistent store, which requires less memory but may have lower performance</li> <li>Caching: Caching frequently accessed Knots and Edges can improve performance but increases memory usage</li> </ul>"},{"location":"performance/memory-compute.html#context-size","title":"Context Size","text":"<p>The size of the Context data affects memory usage during evaluation:</p> <ul> <li>Context Data Size: The size of the data stored in the Context affects memory usage</li> <li>Number of Concurrent Evaluations: The number of concurrent evaluations affects the total memory usage</li> </ul>"},{"location":"performance/memory-compute.html#compute-requirements","title":"Compute Requirements","text":"<p>Bonsai's computational requirements depend on several factors:</p>"},{"location":"performance/memory-compute.html#evaluation-complexity","title":"Evaluation Complexity","text":"<p>The complexity of tree evaluation affects CPU usage:</p> <ul> <li>Tree Depth: Deeper trees require more traversal steps</li> <li>Number of Edges per Knot: More Edges per Knot require more filter evaluations</li> <li>Filter Complexity: More complex filters require more computation</li> <li>Context Size: Larger Context data may require more computation for JsonPath evaluation</li> </ul>"},{"location":"performance/memory-compute.html#operation-frequency","title":"Operation Frequency","text":"<p>The frequency of operations affects CPU usage:</p> <ul> <li>Evaluation Frequency: How often trees are evaluated</li> <li>Modification Frequency: How often trees are modified</li> <li>Batch Size: The number of operations performed in a batch</li> </ul>"},{"location":"performance/memory-compute.html#concurrency","title":"Concurrency","text":"<p>The level of concurrency affects CPU usage:</p> <ul> <li>Number of Concurrent Evaluations: More concurrent evaluations require more CPU resources</li> <li>Number of Concurrent Modifications: More concurrent modifications require more CPU resources</li> <li>Thread Contention: High concurrency can lead to thread contention and reduced performance</li> </ul>"},{"location":"performance/memory-compute.html#memory-optimization-strategies","title":"Memory Optimization Strategies","text":"<p>Here are some strategies for optimizing memory usage:</p>"},{"location":"performance/memory-compute.html#optimize-tree-structure","title":"Optimize Tree Structure","text":"<ul> <li>Limit tree depth: Keep trees shallow to reduce the number of Knots and Edges</li> <li>Reuse Knots: Use the same Knot in multiple places to reduce duplication</li> <li>Minimize property size: Keep properties small and focused</li> <li>Use appropriate KnotData types: Choose the right KnotData type for your data</li> </ul>"},{"location":"performance/memory-compute.html#implement-efficient-storage","title":"Implement Efficient Storage","text":"<ul> <li>Use persistent storage for large trees: Consider using a database or other persistent storage for large trees</li> <li>Implement caching strategically: Cache frequently accessed Knots and Edges, but be mindful of memory usage</li> <li>Consider read/write separation: Use separate instances for read and write operations</li> </ul>"},{"location":"performance/memory-compute.html#optimize-context","title":"Optimize Context","text":"<ul> <li>Keep Context data small: Include only the necessary data in the Context</li> <li>Structure Context data efficiently: Organize data to minimize memory usage</li> <li>Reuse Context objects: Reuse Context objects when possible to reduce allocation overhead</li> </ul>"},{"location":"performance/memory-compute.html#compute-optimization-strategies","title":"Compute Optimization Strategies","text":"<p>Here are some strategies for optimizing compute usage:</p>"},{"location":"performance/memory-compute.html#optimize-evaluation","title":"Optimize Evaluation","text":"<ul> <li>Optimize tree structure: Design trees for efficient evaluation</li> <li>Order Edges effectively: Put the most likely matches first to reduce the number of evaluations</li> <li>Use simple filters: Keep filter conditions simple and focused</li> <li>Batch evaluations: Evaluate multiple keys in a single operation when possible</li> </ul>"},{"location":"performance/memory-compute.html#implement-caching","title":"Implement Caching","text":"<ul> <li>Cache evaluation results: Cache the results of expensive evaluations</li> <li>Use contextual preferences: Bypass tree traversal for frequently accessed keys</li> <li>Implement result caching: Cache evaluation results for frequently used key-context combinations</li> </ul>"},{"location":"performance/memory-compute.html#manage-concurrency","title":"Manage Concurrency","text":"<ul> <li>Limit concurrency: Set appropriate limits on the number of concurrent operations</li> <li>Use thread pools: Use thread pools to manage concurrency</li> <li>Implement backpressure: Implement backpressure mechanisms to prevent overload</li> </ul>"},{"location":"performance/memory-compute.html#monitoring-and-tuning","title":"Monitoring and Tuning","text":"<p>To optimize memory and compute usage effectively:</p> <ul> <li>Monitor memory usage: Track memory usage to identify potential issues</li> <li>Monitor CPU usage: Track CPU usage to identify bottlenecks</li> <li>Profile your application: Use profiling tools to identify hotspots</li> <li>Tune parameters: Adjust parameters based on monitoring and profiling results</li> <li>Test with realistic workloads: Test with representative workloads to ensure optimal performance</li> </ul>"},{"location":"performance/memory-compute.html#scaling-considerations","title":"Scaling Considerations","text":"<p>For high-throughput applications, consider:</p> <ul> <li>Horizontal scaling: Deploy multiple instances of your application</li> <li>Vertical scaling: Increase the resources available to your application</li> <li>Caching: Implement caching at various levels</li> <li>Asynchronous processing: Use asynchronous processing for non-critical operations</li> </ul>"},{"location":"performance/memory-compute.html#example-memory-usage-estimation","title":"Example: Memory Usage Estimation","text":"<p>Here's a rough estimation of memory usage for a Bonsai tree:</p> <ul> <li>Knot: ~100-200 bytes per Knot (excluding KnotData)</li> <li>Edge: ~100-200 bytes per Edge (excluding filters)</li> <li>Filter: ~50-100 bytes per filter</li> <li>String value: ~24 bytes + string length</li> <li>Boolean value: ~16 bytes</li> <li>Number value: ~16-24 bytes</li> <li>JSON value: ~24 bytes + JSON string length</li> </ul> <p>For a tree with: - 1,000 Knots - 2,000 Edges - 5,000 filters - Average of 50 bytes of string data per Knot</p> <p>The estimated memory usage would be: - Knots: 1,000 * 150 bytes = 150,000 bytes - Edges: 2,000 * 150 bytes = 300,000 bytes - Filters: 5,000 * 75 bytes = 375,000 bytes - String data: 1,000 * 50 bytes = 50,000 bytes</p> <p>Total: ~875,000 bytes (~875 KB)</p> <p>This is a rough estimation and actual memory usage may vary based on JVM implementation, object overhead, and other factors.</p>"},{"location":"performance/memory-compute.html#example-compute-usage-estimation","title":"Example: Compute Usage Estimation","text":"<p>Here's a rough estimation of compute usage for Bonsai operations:</p> <ul> <li>Knot retrieval: O(1) with in-memory storage</li> <li>Edge retrieval: O(1) with in-memory storage</li> <li>Tree traversal: O(d) where d is the depth of the tree</li> <li>Filter evaluation: O(f) where f is the number of filters per Edge</li> <li>JsonPath evaluation: O(p) where p is the complexity of the path expression</li> </ul> <p>For a tree with: - Depth of 5 - Average of 10 Edges per Knot - Average of 2 filters per Edge - Simple JsonPath expressions</p> <p>The estimated compute usage for a single evaluation would be: - Tree traversal: 5 steps - Edge evaluations: 5 * 10 = 50 evaluations - Filter evaluations: 50 * 2 = 100 evaluations - JsonPath evaluations: 100 evaluations</p> <p>This is a rough estimation and actual compute usage may vary based on the specific tree structure, context data, and other factors.</p>"},{"location":"performance/memory-compute.html#best-practices","title":"Best Practices","text":"<ul> <li>Start with in-memory storage: Use in-memory storage for development and testing</li> <li>Monitor memory and CPU usage: Track resource usage to identify potential issues</li> <li>Optimize hot paths: Focus optimization efforts on frequently used paths</li> <li>Consider the full lifecycle: Balance creation, evaluation, and maintenance costs</li> <li>Test with realistic workloads: Test with representative workloads to ensure optimal performance</li> <li>Scale appropriately: Choose the right scaling strategy for your application</li> </ul>"},{"location":"performance/optimizing-tree-structure.html","title":"Optimizing Tree Structure","text":"<p>The structure of your Bonsai trees has a significant impact on performance. This guide provides recommendations for designing efficient tree structures that optimize evaluation performance.</p>"},{"location":"performance/optimizing-tree-structure.html#tree-depth","title":"Tree Depth","text":"<p>The depth of a tree is the number of edges that need to be traversed from the root to the deepest leaf. Deep trees can lead to longer evaluation times:</p> <ul> <li>Keep trees shallow: Aim for a maximum depth of 5-10 levels</li> <li>Use flatter structures: Consider reorganizing deep hierarchies into flatter structures</li> <li>Balance the tree: Distribute decision points evenly to avoid heavily skewed trees</li> </ul>"},{"location":"performance/optimizing-tree-structure.html#edge-count-and-order","title":"Edge Count and Order","text":"<p>The number of edges per knot and their order affects how quickly Bonsai can find the right path:</p> <ul> <li>Limit edges per knot: Keep the number of edges per knot below 10-20</li> <li>Order edges by likelihood: Put the most likely matches first to reduce the number of evaluations</li> <li>Use default edges wisely: Always include a default edge (with no filters) as the last edge on a knot</li> </ul> <p>Example of ordering edges by likelihood:</p> <pre><code>// Add the most common case first\nbonsai.addVariation(rootKnot.getId(), Variation.builder()\n    .knotId(commonCaseKnot.getId())\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.user.type\")\n            .operator(Operator.EQUALS)\n            .value(\"regular\")\n            .build()\n    ))\n    .build());\n\n// Add less common cases next\nbonsai.addVariation(rootKnot.getId(), Variation.builder()\n    .knotId(premiumCaseKnot.getId())\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.user.type\")\n            .operator(Operator.EQUALS)\n            .value(\"premium\")\n            .build()\n    ))\n    .build());\n\n// Add the default case last\nbonsai.addVariation(rootKnot.getId(), Variation.builder()\n    .knotId(defaultCaseKnot.getId())\n    .filters(List.of())\n    .build());\n</code></pre>"},{"location":"performance/optimizing-tree-structure.html#filter-complexity","title":"Filter Complexity","text":"<p>The complexity of filter conditions affects evaluation time:</p> <ul> <li>Use simple filters: Keep filter conditions simple and focused</li> <li>Limit the number of filters per edge: Keep the number of filters per edge below 5-10</li> <li>Avoid complex JsonPath expressions: Complex expressions can be expensive to evaluate</li> <li>Use efficient operators: Some operators are more efficient than others</li> </ul> <p>Example of simplifying filters:</p> <pre><code>// Instead of this complex filter\nbonsai.addVariation(rootKnot.getId(), Variation.builder()\n    .knotId(targetKnot.getId())\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.user.preferences.settings.theme.color\")\n            .operator(Operator.EQUALS)\n            .value(\"dark\")\n            .build()\n    ))\n    .build());\n\n// Consider restructuring your context data\n// And using a simpler filter\nbonsai.addVariation(rootKnot.getId(), Variation.builder()\n    .knotId(targetKnot.getId())\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.user.theme\")\n            .operator(Operator.EQUALS)\n            .value(\"dark\")\n            .build()\n    ))\n    .build());\n</code></pre>"},{"location":"performance/optimizing-tree-structure.html#tree-structure-patterns","title":"Tree Structure Patterns","text":"<p>Certain tree structure patterns can lead to better performance:</p>"},{"location":"performance/optimizing-tree-structure.html#decision-trees","title":"Decision Trees","text":"<p>For simple decision logic, use a traditional decision tree structure:</p> <pre><code>Root Knot\n\u251c\u2500\u2500 Edge: If condition A \u2192 Knot A\n\u251c\u2500\u2500 Edge: If condition B \u2192 Knot B\n\u2514\u2500\u2500 Edge: Default \u2192 Default Knot\n</code></pre> <p>This structure is efficient for simple decisions with a small number of outcomes.</p>"},{"location":"performance/optimizing-tree-structure.html#two-level-trees","title":"Two-Level Trees","text":"<p>For configuration selection, consider a two-level tree structure:</p> <pre><code>Root Knot\n\u251c\u2500\u2500 Edge: If condition A \u2192 Config A Knot\n\u251c\u2500\u2500 Edge: If condition B \u2192 Config B Knot\n\u2514\u2500\u2500 Edge: Default \u2192 Default Config Knot\n</code></pre> <p>This structure is efficient for selecting one of several configurations based on conditions.</p>"},{"location":"performance/optimizing-tree-structure.html#segmentation-trees","title":"Segmentation Trees","text":"<p>For user segmentation, consider a segmentation tree structure:</p> <pre><code>Root Knot\n\u251c\u2500\u2500 Edge: If user is premium \u2192 Premium Segment Knot\n\u2502   \u251c\u2500\u2500 Edge: If user is new \u2192 New Premium User Knot\n\u2502   \u2514\u2500\u2500 Edge: Default \u2192 Regular Premium User Knot\n\u251c\u2500\u2500 Edge: If user is free \u2192 Free Segment Knot\n\u2502   \u251c\u2500\u2500 Edge: If user is new \u2192 New Free User Knot\n\u2502   \u2514\u2500\u2500 Edge: Default \u2192 Regular Free User Knot\n\u2514\u2500\u2500 Edge: Default \u2192 Unknown Segment Knot\n</code></pre> <p>This structure efficiently segments users into groups and subgroups.</p>"},{"location":"performance/optimizing-tree-structure.html#feature-flag-trees","title":"Feature Flag Trees","text":"<p>For feature flags, consider a feature flag tree structure:</p> <pre><code>Root Knot (Map)\n\u251c\u2500\u2500 \"feature1\" \u2192 Feature 1 Knot\n\u2502   \u251c\u2500\u2500 Edge: If user is in beta \u2192 Enabled Knot\n\u2502   \u2514\u2500\u2500 Edge: Default \u2192 Disabled Knot\n\u251c\u2500\u2500 \"feature2\" \u2192 Feature 2 Knot\n\u2502   \u251c\u2500\u2500 Edge: If user is premium \u2192 Enabled Knot\n\u2502   \u2514\u2500\u2500 Edge: Default \u2192 Disabled Knot\n\u2514\u2500\u2500 \"feature3\" \u2192 Feature 3 Knot\n    \u251c\u2500\u2500 Edge: If user is in region A \u2192 Enabled Knot\n    \u2514\u2500\u2500 Edge: Default \u2192 Disabled Knot\n</code></pre> <p>This structure efficiently manages multiple feature flags.</p>"},{"location":"performance/optimizing-tree-structure.html#reusing-knots","title":"Reusing Knots","text":"<p>Reusing knots can reduce memory usage and improve cache efficiency:</p> <ul> <li>Identify common subtrees: Look for patterns that repeat in your tree structure</li> <li>Extract common subtrees: Create separate knots for common subtrees</li> <li>Reference common knots: Use the same knot in multiple places</li> </ul> <p>Example of reusing knots:</p> <pre><code>// Create common knots\nKnot enabledKnot = bonsai.createKnot(\n    ValuedKnotData.builder().booleanValue(true).build(),\n    Map.of(\"description\", \"Feature enabled\")\n);\n\nKnot disabledKnot = bonsai.createKnot(\n    ValuedKnotData.builder().booleanValue(false).build(),\n    Map.of(\"description\", \"Feature disabled\")\n);\n\n// Reuse the common knots in multiple places\nbonsai.addVariation(feature1Knot.getId(), Variation.builder()\n    .knotId(enabledKnot.getId())\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.user.beta\")\n            .operator(Operator.EQUALS)\n            .value(true)\n            .build()\n    ))\n    .build());\n\nbonsai.addVariation(feature1Knot.getId(), Variation.builder()\n    .knotId(disabledKnot.getId())\n    .filters(List.of())\n    .build());\n\nbonsai.addVariation(feature2Knot.getId(), Variation.builder()\n    .knotId(enabledKnot.getId())\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.user.premium\")\n            .operator(Operator.EQUALS)\n            .value(true)\n            .build()\n    ))\n    .build());\n\nbonsai.addVariation(feature2Knot.getId(), Variation.builder()\n    .knotId(disabledKnot.getId())\n    .filters(List.of())\n    .build());\n</code></pre>"},{"location":"performance/optimizing-tree-structure.html#context-structure","title":"Context Structure","text":"<p>The structure of your context data can also affect performance:</p> <ul> <li>Keep context data small: Include only the necessary data in the context</li> <li>Structure context data for efficient access: Organize data to minimize the complexity of JsonPath expressions</li> <li>Flatten deeply nested structures: Consider flattening deeply nested structures to simplify JsonPath expressions</li> </ul> <p>Example of restructuring context data:</p> <pre><code>// Instead of this deeply nested structure\n{\n    \"user\": {\n        \"preferences\": {\n            \"settings\": {\n                \"theme\": {\n                    \"color\": \"dark\"\n                }\n            }\n        }\n    }\n}\n\n// Consider this flatter structure\n{\n    \"user\": {\n        \"theme\": \"dark\"\n    }\n}\n</code></pre>"},{"location":"performance/optimizing-tree-structure.html#measuring-and-testing","title":"Measuring and Testing","text":"<p>To optimize your tree structure effectively:</p> <ul> <li>Measure baseline performance: Establish a baseline for comparison</li> <li>Test with realistic data: Use representative data for testing</li> <li>Isolate changes: Test one optimization at a time</li> <li>Measure the impact: Quantify the performance improvement of each optimization</li> <li>Consider trade-offs: Balance performance with maintainability and readability</li> </ul>"},{"location":"performance/optimizing-tree-structure.html#best-practices","title":"Best Practices","text":"<ul> <li>Start simple: Begin with a simple tree structure and optimize as needed</li> <li>Focus on hot paths: Optimize the most frequently used paths first</li> <li>Consider the full lifecycle: Balance creation, evaluation, and maintenance costs</li> <li>Document your design decisions: Document why you structured the tree a certain way</li> <li>Review and refactor: Periodically review and refactor your tree structure</li> <li>Test thoroughly: Test your optimizations with various inputs and edge cases</li> </ul>"},{"location":"troubleshooting/index.html","title":"Troubleshooting","text":"<p>Even with careful design and implementation, you may encounter issues when working with Bonsai. This section provides guidance on troubleshooting common problems and offers tips for debugging and resolving issues.</p>"},{"location":"troubleshooting/index.html#topics-covered","title":"Topics Covered","text":"<ul> <li>Common Errors: Learn about common errors and how to resolve them</li> <li>Debugging Tips: Explore techniques for debugging Bonsai applications</li> </ul>"},{"location":"troubleshooting/index.html#general-troubleshooting-approach","title":"General Troubleshooting Approach","text":"<p>When troubleshooting issues with Bonsai, follow these general steps:</p> <ol> <li>Identify the problem: Determine what's not working as expected</li> <li>Check error messages: Look for error messages in logs or exceptions</li> <li>Verify inputs: Ensure that inputs to Bonsai operations are valid</li> <li>Check tree structure: Verify that the tree structure is valid</li> <li>Trace execution: Trace the execution of Bonsai operations</li> <li>Isolate the issue: Try to isolate the issue to a specific component</li> <li>Test with simplified cases: Test with simplified cases to narrow down the problem</li> <li>Check documentation: Refer to the documentation for guidance</li> <li>Seek help: If you can't resolve the issue, seek help from the community</li> </ol>"},{"location":"troubleshooting/index.html#common-issues","title":"Common Issues","text":"<p>Here are some common issues you might encounter when working with Bonsai:</p> <ul> <li>Tree traversal not working as expected: The tree is not being traversed as expected</li> <li>Conditions not evaluating correctly: Conditions on Edges are not evaluating as expected</li> <li>Performance issues: Bonsai operations are taking longer than expected</li> <li>Memory usage issues: Bonsai is using more memory than expected</li> <li>Concurrency issues: Issues with concurrent modifications</li> <li>Storage issues: Issues with storing or retrieving Knots and Edges</li> <li>Versioning issues: Issues with versioning of Knots and Edges</li> </ul>"},{"location":"troubleshooting/common-errors.html","title":"Common Errors","text":"<p>This guide covers common errors you might encounter when working with Bonsai and provides guidance on how to resolve them.</p>"},{"location":"troubleshooting/common-errors.html#bonsaierror","title":"BonsaiError","text":"<p>Bonsai throws a <code>BonsaiError</code> when an operation fails. The error includes an error code and a message that provides more information about the error.</p> <pre><code>try {\n    KeyNode result = bonsai.evaluate(\"nonExistentKey\", context);\n} catch (BonsaiError e) {\n    System.err.println(\"Error code: \" + e.getErrorCode());\n    System.err.println(\"Error message: \" + e.getMessage());\n}\n</code></pre>"},{"location":"troubleshooting/common-errors.html#common-error-codes","title":"Common Error Codes","text":"Error Code Description Resolution CYCLE_DETECTED A cycle was detected in the tree structure Review your tree structure to ensure there are no circular references VARIATION_MUTUAL_EXCLUSIVITY_CONSTRAINT_ERROR Edge variations violate mutual exclusivity Ensure edge conditions don't overlap when mutual exclusivity is enabled TREE_ALREADY_EXIST Tree creation through delta ops failure A tree for the said key mapping already exists, try with a new key MAX_VARIATIONS_EXCEEDED Too many variations on a knot Increase the maxAllowedVariationsPerKnot property or restructure your tree MAX_CONDITIONS_EXCEEDED Too many conditions on an edge Increase the maxAllowedConditionsPerEdge property or simplify your conditions"},{"location":"troubleshooting/common-errors.html#key_not_found","title":"KEY_NOT_FOUND","text":"<p>This error occurs when you try to evaluate a key that doesn't exist.</p> <pre><code>try {\n    KeyNode result = bonsai.evaluate(\"nonExistentKey\", context);\n} catch (BonsaiError e) {\n    if (e.getErrorCode() == BonsaiErrorCode.KEY_NOT_FOUND) {\n        // Handle key not found error\n        System.err.println(\"Key not found: \" + e.getMessage());\n    }\n}\n</code></pre> <p>Resolution: - Check that the key exists in the key-tree store - Use <code>bonsai.hasKey(key)</code> to check if a key exists before evaluating it - Create the key mapping if it doesn't exist</p>"},{"location":"troubleshooting/common-errors.html#knot_absent","title":"KNOT_ABSENT","text":"<p>This error occurs when you try to access a Knot that doesn't exist.</p> <pre><code>try {\n    Knot knot = bonsai.getKnot(\"nonExistentKnotId\");\n} catch (BonsaiError e) {\n    if (e.getErrorCode() == BonsaiErrorCode.KNOT_ABSENT) {\n        // Handle knot not found error\n        System.err.println(\"Knot not found: \" + e.getMessage());\n    }\n}\n</code></pre> <p>Resolution: - Check that the Knot ID is correct - Use <code>bonsai.hasKnot(knotId)</code> to check if a Knot exists before accessing it - Create the Knot if it doesn't exist</p>"},{"location":"troubleshooting/common-errors.html#edge_absent","title":"EDGE_ABSENT","text":"<p>This error occurs when you try to access an Edge that doesn't exist.</p> <pre><code>try {\n    Edge edge = bonsai.getEdge(\"nonExistentEdgeId\");\n} catch (BonsaiError e) {\n    if (e.getErrorCode() == BonsaiErrorCode.EDGE_ABSENT) {\n        // Handle edge not found error\n        System.err.println(\"Edge not found: \" + e.getMessage());\n    }\n}\n</code></pre> <p>Resolution: - Check that the Edge ID is correct - Use <code>bonsai.hasEdge(edgeId)</code> to check if an Edge exists before accessing it - Create the Edge if it doesn't exist</p>"},{"location":"troubleshooting/common-errors.html#cycle_detected","title":"CYCLE_DETECTED","text":"<p>This error occurs when a cycle is detected in the tree structure.</p> <pre><code>try {\n    TreeKnotState result = bonsai.applyDeltaOperations(\"rootKey\", operations);\n} catch (BonsaiError e) {\n    if (e.getErrorCode() == BonsaiErrorCode.CYCLE_DETECTED) {\n        // Handle cycle detected error\n        System.err.println(\"Cycle detected: \" + e.getMessage());\n    }\n}\n</code></pre> <p>Resolution: - Check the tree structure for cycles - Ensure that Edges don't create cycles - Use a validator to check for cycles before applying changes</p>"},{"location":"troubleshooting/common-errors.html#invalid_input","title":"INVALID_INPUT","text":"<p>This error occurs when the KnotData or filters are invalid</p> <pre><code>try {\n    Knot knot = bonsai.createKnot(\n        null, // Invalid KnotData\n        Map.of(\"description\", \"Invalid knot\")\n    );\n} catch (BonsaiError e) {\n    if (e.getErrorCode() == BonsaiErrorCode.INVALID_INPUT) {\n        // Handle invalid knot data error\n        System.err.println(\"Invalid knot data: \" + e.getMessage());\n    }\n}\n</code></pre> <p>Resolution: - Check that the KnotData is valid - Ensure that the KnotData is appropriate for the Knot type - Validate KnotData before creating or updating Knots</p>"},{"location":"troubleshooting/common-errors.html#runtime-errors","title":"Runtime Errors","text":""},{"location":"troubleshooting/common-errors.html#outofmemoryerror","title":"OutOfMemoryError","text":"<p>This error occurs when the JVM runs out of memory.</p> <pre><code>java.lang.OutOfMemoryError: Java heap space\n</code></pre> <p>Resolution: - Increase the JVM heap size (e.g., <code>-Xmx2g</code>) - Optimize memory usage (e.g., reuse Knots, limit tree depth) - Implement caching to reduce memory pressure - Consider using persistent storage for large trees</p>"},{"location":"troubleshooting/common-errors.html#stackoverflowerror","title":"StackOverflowError","text":"<p>This error occurs when the call stack exceeds its limit, often due to infinite recursion.</p> <pre><code>java.lang.StackOverflowError\n</code></pre> <p>Resolution: - Check for cycles in the tree structure - Limit tree depth - Optimize recursive operations - Increase the stack size (e.g., <code>-Xss2m</code>)</p>"},{"location":"troubleshooting/common-errors.html#concurrency-errors","title":"Concurrency Errors","text":""},{"location":"troubleshooting/common-errors.html#concurrentmodificationexception","title":"ConcurrentModificationException","text":"<p>This error occurs when a collection is modified while being iterated.</p> <pre><code>java.util.ConcurrentModificationException\n</code></pre> <p>Resolution: - Use thread-safe collections - Synchronize access to shared collections - Use concurrent data structures - Implement proper locking</p>"},{"location":"troubleshooting/common-errors.html#best-practices-for-error-handling","title":"Best Practices for Error Handling","text":"<ul> <li>Use try-catch blocks: Wrap Bonsai operations in try-catch blocks to handle errors</li> <li>Check error codes: Check the error code to determine the type of error</li> <li>Provide meaningful error messages: Include relevant information in error messages</li> <li>Log errors: Log errors for debugging and monitoring</li> <li>Implement retry logic: Implement retry logic for transient errors</li> <li>Validate inputs: Validate inputs before passing them to Bonsai</li> <li>Test error scenarios: Test error scenarios to ensure proper error handling</li> <li>Provide fallbacks: Provide fallback values or behavior when errors occur</li> </ul>"},{"location":"troubleshooting/debugging-tips.html","title":"Debugging Tips","text":"<p>Debugging Bonsai applications can be challenging due to the complex nature of tree structures and conditional logic. This guide provides tips and techniques for debugging Bonsai applications effectively.</p>"},{"location":"troubleshooting/debugging-tips.html#logging","title":"Logging","text":""},{"location":"troubleshooting/debugging-tips.html#add-logging-to-key-operations","title":"Add Logging to Key Operations","text":"<p>Add logging statements to key operations to trace the execution flow:</p> <pre><code>// Add logging to trace Bonsai operations\nLogger logger = LoggerFactory.getLogger(YourClass.class);\n\n// Log before evaluating a tree\nlogger.debug(\"Evaluating tree for key: {}\", key);\n\n// Log the context data\nlogger.debug(\"Context data: {}\", context.getDocumentContext().jsonString());\n\n// Log the result\nKeyNode result = bonsai.evaluate(key, context);\nlogger.debug(\"Evaluation result: {}\", result);\n</code></pre>"},{"location":"troubleshooting/debugging-tips.html#tracing","title":"Tracing","text":"<p>Bonsai provides a <code>TraceWrappedJsonPathFilterEvaluationEngine</code> that can be used to trace filter evaluation/ This gets used by default, if log level is set to <code>TRACE</code>. </p>"},{"location":"troubleshooting/debugging-tips.html#flat-evaluation","title":"Flat Evaluation","text":"<p>Bonsai provides a <code>evaluateFlat</code> method that returns a flat representation of the evaluated tree:</p> <pre><code>// Get a flat representation of the evaluated tree\nFlatTreeRepresentation flatTree = bonsai.evaluateFlat(\"key\", context);\n\n// Access the flat tree information\nString rootKnotId = flatTree.getRootKnotId();\nMap&lt;String, Knot&gt; knots = flatTree.getKnots();\nMap&lt;String, Edge&gt; edges = flatTree.getEdges();\nList&lt;String&gt; traversedEdgeIds = flatTree.getTraversedEdgeIds();\n\n// Print the traversed path\nSystem.out.println(\"Root knot: \" + knots.get(rootKnotId));\nfor (String edgeId : traversedEdgeIds) {\n    Edge edge = edges.get(edgeId);\n    Knot targetKnot = knots.get(edge.getTargetKnotId());\n    System.out.println(\"Edge: \" + edge);\n    System.out.println(\"Target knot: \" + targetKnot);\n}\n</code></pre>"},{"location":"troubleshooting/debugging-tips.html#performance-issues","title":"Performance Issues","text":"<p>If Bonsai operations are taking longer than expected:</p> <ul> <li>Optimize the tree structure</li> <li>Limit the depth of the tree</li> <li>Reduce the number of Edges per Knot</li> <li>Simplify filter conditions</li> <li>Implement caching</li> </ul>"},{"location":"troubleshooting/debugging-tips.html#memory-issues","title":"Memory Issues","text":"<p>If Bonsai is using more memory than expected:</p> <ul> <li>Limit the size of the tree</li> <li>Reuse Knots where possible</li> <li>Optimize KnotData</li> <li>Consider using persistent storage</li> </ul>"},{"location":"usage/index.html","title":"Usage","text":"<p>This section provides practical examples and guidance on how to use Bonsai in your applications. </p>"},{"location":"usage/index.html#getting-started","title":"Getting Started","text":"<p>To start using Bonsai in your Java application, you'll need to:</p> <ol> <li>Install Bonsai by adding it to your project dependencies</li> <li>Create a Bonsai instance with appropriate configuration</li> <li>Build trees to represent your rule structure</li> <li>Evaluate trees against a context to get results</li> <li>Apply delta operations to modify trees as needed</li> </ol>"},{"location":"usage/index.html#basic-workflow","title":"Basic Workflow","text":"<p>The typical workflow for using Bonsai involves:</p> <ol> <li>Setup: Create a Bonsai instance with appropriate storage implementations and configuration</li> <li>Tree Building: Create Knots, connect them with Edges, and map keys to root Knots</li> <li>Evaluation: Create a Context with the data to evaluate, and evaluate a key against it</li> <li>Result Processing: Process the evaluation result (KeyNode) to extract the data</li> <li>Maintenance: Update the tree structure as needed over time</li> </ol>"},{"location":"usage/index.html#example-user-eligibility-check","title":"Example: User Eligibility Check","text":"<p>Here's a simple example of using Bonsai to check if a user is eligible for a service:</p> <pre><code>// Create a Bonsai instance\nBonsai&lt;Context&gt; bonsai = BonsaiBuilder.builder()\n    .withBonsaiProperties(BonsaiProperties.builder().build())\n    .withEdgeStore(new InMemoryEdgeStore())\n    .withKeyTreeStore(new InMemoryKeyTreeStore())\n    .withKnotStore(new InMemoryKnotStore())\n    .build();\n\n// Create leaf knots with values\nKnot eligibleKnot = bonsai.createKnot(\n    ValuedKnotData.builder().booleanValue(true).build(),\n    Map.of(\"description\", \"User is eligible\")\n);\n\nKnot ineligibleKnot = bonsai.createKnot(\n    ValuedKnotData.builder().booleanValue(false).build(),\n    Map.of(\"description\", \"User is ineligible\")\n);\n\n// Create the root knot\nKnot rootKnot = bonsai.createKnot(\n    ValuedKnotData.builder().build(),\n    Map.of(\"description\", \"User eligibility decision point\")\n);\n\n// Add variations to the root knot\nbonsai.addVariation(rootKnot.getId(), Variation.builder()\n    .knotId(eligibleKnot.getId())\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.user.age\")\n            .operator(Operator.GREATER_THAN_EQUAL)\n            .value(18)\n            .build(),\n        Filter.builder()\n            .path(\"$.user.country\")\n            .operator(Operator.IN)\n            .value(List.of(\"US\", \"CA\", \"UK\"))\n            .build()\n    ))\n    .build());\n\nbonsai.addVariation(rootKnot.getId(), Variation.builder()\n    .knotId(ineligibleKnot.getId())\n    .filters(List.of())\n    .build());\n\n// Map a key to the root knot\nbonsai.createMapping(\"userEligibility\", rootKnot.getId());\n\n// Create a context for evaluation\nString json = \"{\\\"user\\\": {\\\"age\\\": 25, \\\"country\\\": \\\"US\\\"}}\";\nContext context = Context.builder()\n    .documentContext(JsonPath.parse(json))\n    .build();\n\n// Evaluate the tree\nKeyNode result = bonsai.evaluate(\"userEligibility\", context);\n\n// Access the evaluation result\nBoolean isEligible = result.getValue().getBooleanValue();\nSystem.out.println(\"User is eligible: \" + isEligible); // true\n</code></pre>"},{"location":"usage/building-trees.html","title":"Building Trees","text":"<p>Building tree structures is a core part of using Bonsai. This section gives several examples of building  custom trees to paint the picture of how trees are created. But in practice, in you application, you would do this through a set of APIs exposed by your application, and potentially, a UI on the other side that is facilitating the  construction of these tress.</p>"},{"location":"usage/building-trees.html#basic-tree-building","title":"Basic Tree Building","text":"<p>A typical Bonsai tree consists of:</p> <ol> <li>Leaf Knots containing values</li> <li>Decision Knots with conditional Edges</li> <li>Root Knots mapped to keys</li> </ol> <p>Here's a simple example of building a tree for user eligibility:</p> <pre><code>// Create a Bonsai instance\nBonsai&lt;Context&gt; bonsai = BonsaiBuilder.builder()\n    .withBonsaiProperties(BonsaiProperties.builder().build())\n    .withEdgeStore(new InMemoryEdgeStore())\n    .withKeyTreeStore(new InMemoryKeyTreeStore())\n    .withKnotStore(new InMemoryKnotStore())\n    .build();\n\n// Create leaf knots with values\nKnot eligibleKnot = bonsai.createKnot(\n    ValuedKnotData.builder().booleanValue(true).build(),\n    Map.of(\"description\", \"User is eligible\")\n);\n\nKnot ineligibleKnot = bonsai.createKnot(\n    ValuedKnotData.builder().booleanValue(false).build(),\n    Map.of(\"description\", \"User is ineligible\")\n);\n\n// Create the root knot\nKnot rootKnot = bonsai.createKnot(\n    ValuedKnotData.builder().build(),\n    Map.of(\"description\", \"User eligibility decision point\")\n);\n\n// Add variations to the root knot\nbonsai.addVariation(rootKnot.getId(), Variation.builder()\n    .knotId(eligibleKnot.getId())\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.user.age\")\n            .operator(Operator.GREATER_THAN_EQUAL)\n            .value(18)\n            .build(),\n        Filter.builder()\n            .path(\"$.user.country\")\n            .operator(Operator.IN)\n            .value(List.of(\"US\", \"CA\", \"UK\"))\n            .build()\n    ))\n    .build());\n\n// Add a default variation (no filters) for ineligible users\nbonsai.addVariation(rootKnot.getId(), Variation.builder()\n    .knotId(ineligibleKnot.getId())\n    .filters(List.of())\n    .build());\n\n// Map a key to the root knot\nbonsai.createMapping(\"userEligibility\", rootKnot.getId());\n</code></pre>"},{"location":"usage/building-trees.html#creating-different-types-of-knots","title":"Creating Different Types of Knots","text":""},{"location":"usage/building-trees.html#value-knots","title":"Value Knots","text":"<p>Value Knots contain primitive values:</p> <pre><code>// String value\nKnot stringKnot = bonsai.createKnot(\n    ValuedKnotData.builder().stringValue(\"Hello, World!\").build(),\n    Map.of(\"description\", \"A string knot\")\n);\n\n// Boolean value\nKnot booleanKnot = bonsai.createKnot(\n    ValuedKnotData.builder().booleanValue(true).build(),\n    Map.of(\"description\", \"A boolean knot\")\n);\n\n// Number value\nKnot numberKnot = bonsai.createKnot(\n    ValuedKnotData.builder().numberValue(42.5).build(),\n    Map.of(\"description\", \"A number knot\")\n);\n\n// JSON value\nKnot jsonKnot = bonsai.createKnot(\n    ValuedKnotData.builder().jsonValue(\"{\\\"name\\\":\\\"John\\\",\\\"age\\\":30}\").build(),\n    Map.of(\"description\", \"A JSON knot\")\n);\n</code></pre>"},{"location":"usage/building-trees.html#list-knots","title":"List Knots","text":"<p>List Knots contain references to multiple other Knots:</p> <pre><code>// Create a list knot\nKnot listKnot = bonsai.createKnot(\n    MultiKnotData.builder()\n        .knotIds(List.of(\"knot1\", \"knot2\", \"knot3\"))\n        .build(),\n    Map.of(\"description\", \"A list knot\")\n);\n</code></pre>"},{"location":"usage/building-trees.html#map-knots","title":"Map Knots","text":"<p>Map Knots contain key-based references to other Knots:</p> <pre><code>// Create a map knot\nKnot mapKnot = bonsai.createKnot(\n    MapKnotData.builder()\n        .keyMapping(Map.of(\n            \"name\", nameKnot.getId(),\n            \"age\", ageKnot.getId(),\n            \"isActive\", activeKnot.getId()\n        ))\n        .build(),\n    Map.of(\"description\", \"A map knot\")\n);\n</code></pre>"},{"location":"usage/building-trees.html#creating-edges-with-different-conditions","title":"Creating Edges with Different Conditions","text":"<p>Edges (or Variations) connect Knots and define conditional paths through the tree. Here are examples of different types of conditions:</p> <pre><code>// Equals condition\nbonsai.addVariation(rootKnot.getId(), Variation.builder()\n    .knotId(targetKnot.getId())\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.user.type\")\n            .operator(Operator.EQUALS)\n            .value(\"premium\")\n            .build()\n    ))\n    .build());\n\n// Greater than condition\nbonsai.addVariation(rootKnot.getId(), Variation.builder()\n    .knotId(targetKnot.getId())\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.user.age\")\n            .operator(Operator.GREATER_THAN)\n            .value(18)\n            .build()\n    ))\n    .build());\n\n// In condition (membership in a list)\nbonsai.addVariation(rootKnot.getId(), Variation.builder()\n    .knotId(targetKnot.getId())\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.user.country\")\n            .operator(Operator.IN)\n            .value(List.of(\"US\", \"CA\", \"UK\"))\n            .build()\n    ))\n    .build());\n\n// Contains condition (substring match)\nbonsai.addVariation(rootKnot.getId(), Variation.builder()\n    .knotId(targetKnot.getId())\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.user.email\")\n            .operator(Operator.CONTAINS)\n            .value(\"@example.com\")\n            .build()\n    ))\n    .build());\n\n// Regex condition (pattern match)\nbonsai.addVariation(rootKnot.getId(), Variation.builder()\n    .knotId(targetKnot.getId())\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.user.phone\")\n            .operator(Operator.REGEX)\n            .value(\"^\\\\+1-\\\\d{3}-\\\\d{3}-\\\\d{4}$\")\n            .build()\n    ))\n    .build());\n\n// Multiple conditions (AND logic)\nbonsai.addVariation(rootKnot.getId(), Variation.builder()\n    .knotId(targetKnot.getId())\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.user.age\")\n            .operator(Operator.GREATER_THAN_EQUAL)\n            .value(18)\n            .build(),\n        Filter.builder()\n            .path(\"$.user.country\")\n            .operator(Operator.IN)\n            .value(List.of(\"US\", \"CA\", \"UK\"))\n            .build()\n    ))\n    .build());\n\n// Default condition (no filters)\nbonsai.addVariation(rootKnot.getId(), Variation.builder()\n    .knotId(defaultKnot.getId())\n    .filters(List.of())\n    .build());\n</code></pre>"},{"location":"usage/building-trees.html#building-complex-nested-structures","title":"Building Complex Nested Structures","text":"<p>Bonsai allows you to create complex nested structures using Map and List Knots:</p> <pre><code>// Create leaf knots with values\nKnot nameKnot = bonsai.createKnot(\n    ValuedKnotData.builder().stringValue(\"John Doe\").build(),\n    Map.of()\n);\n\nKnot ageKnot = bonsai.createKnot(\n    ValuedKnotData.builder().numberValue(30).build(),\n    Map.of()\n);\n\nKnot activeKnot = bonsai.createKnot(\n    ValuedKnotData.builder().booleanValue(true).build(),\n    Map.of()\n);\n\n// Create a user profile knot that references the leaf knots\nKnot userProfileKnot = bonsai.createKnot(\n    MapKnotData.builder()\n        .keyMapping(Map.of(\n            \"name\", nameKnot.getId(),\n            \"age\", ageKnot.getId(),\n            \"active\", activeKnot.getId()\n        ))\n        .build(),\n    Map.of(\"description\", \"User profile data\")\n);\n\n// Create a list of user profiles\nKnot userListKnot = bonsai.createKnot(\n    MultiKnotData.builder()\n        .knotIds(List.of(userProfileKnot.getId(), otherUserProfileKnot.getId()))\n        .build(),\n    Map.of(\"description\", \"List of user profiles\")\n);\n\n// Map a key to the user list knot\nbonsai.createMapping(\"users\", userListKnot.getId());\n</code></pre>"},{"location":"usage/building-trees.html#creating-complete-trees","title":"Creating Complete Trees","text":"<p>You can create a complete tree structure in one operation using the <code>createCompleteTree</code> method:</p> <pre><code>// Create a TreeKnot structure\nTreeKnot treeKnot = TreeKnot.builder()\n    .id(\"rootKnot\")\n    .data(ValuedKnotData.builder().build())\n    .properties(Map.of(\"description\", \"Root knot\"))\n    .edges(List.of(\n        TreeEdge.builder()\n            .id(\"edge1\")\n            .filters(List.of(\n                Filter.builder()\n                    .path(\"$.user.age\")\n                    .operator(Operator.GREATER_THAN_EQUAL)\n                    .value(18)\n                    .build()\n            ))\n            .targetKnot(\n                TreeKnot.builder()\n                    .id(\"eligibleKnot\")\n                    .data(ValuedKnotData.builder().booleanValue(true).build())\n                    .properties(Map.of(\"description\", \"User is eligible\"))\n                    .build()\n            )\n            .build(),\n        TreeEdge.builder()\n            .id(\"edge2\")\n            .filters(List.of())\n            .targetKnot(\n                TreeKnot.builder()\n                    .id(\"ineligibleKnot\")\n                    .data(ValuedKnotData.builder().booleanValue(false).build())\n                    .properties(Map.of(\"description\", \"User is ineligible\"))\n                    .build()\n            )\n            .build()\n    ))\n    .build();\n\n// Create the complete tree\nKnot rootKnot = bonsai.createCompleteTree(treeKnot);\n\n// Map a key to the root knot\nbonsai.createMapping(\"userEligibility\", rootKnot.getId());\n</code></pre>"},{"location":"usage/building-trees.html#best-practices","title":"Best Practices","text":"<ul> <li>Plan your tree structure: Design your tree structure before implementing it</li> <li>Use meaningful IDs and descriptions: Make your tree easier to understand and maintain</li> <li>Order variations appropriately: Remember that variations are evaluated in order</li> <li>Include default variations: Always include a default variation (with no filters) as the last variation on a knot</li> <li>Keep trees shallow: Minimize the depth of your trees for better performance</li> <li>Reuse knots: Use the same knot in multiple places to avoid duplication</li> <li>Use appropriate knot types: Choose the right knot type (value, list, or map) for your data</li> <li>Validate your trees: Use the validator to ensure your trees are valid</li> </ul>"},{"location":"usage/creating-bonsai.html","title":"Creating a Bonsai Instance","text":"<p>Creating a properly configured Bonsai instance is the first step in using the Bonsai rule engine. This guide explains the various configuration options and how to create a Bonsai instance tailored to your needs.</p>"},{"location":"usage/creating-bonsai.html#using-the-bonsaibuilder","title":"Using the BonsaiBuilder","text":"<p>The recommended way to create a Bonsai instance is using the <code>BonsaiBuilder</code> class. In a production environment, the  properties could come from an external configuration.</p> <pre><code>Bonsai&lt;Context&gt; bonsai = BonsaiBuilder.builder()\n    .withBonsaiProperties(\n        BonsaiProperties.builder()\n            .maxAllowedVariationsPerKnot(10)  // Limit variations per knot\n            .maxAllowedConditionsPerEdge(10)  // Limit conditions per variation\n            .mutualExclusivitySettingTurnedOn(false)\n            .build())\n    .withBonsaiIdGenerator(new UUIDGenerator())    // Custom ID generation strategy, which you can create\n    .withEdgeStore(new InMemoryEdgeStore())        // Edge storage implementation\n    .withKeyTreeStore(new InMemoryKeyTreeStore())  // Key-Tree mapping storage\n    .withKnotStore(new InMemoryKnotStore())        // Knot storage implementation\n    .build();\n</code></pre>"},{"location":"usage/creating-bonsai.html#configuration-options","title":"Configuration Options","text":""},{"location":"usage/creating-bonsai.html#bonsaiproperties","title":"BonsaiProperties","text":"<p><code>BonsaiProperties</code> controls the behavior of the Bonsai instance:</p> <pre><code>BonsaiProperties properties = BonsaiProperties.builder()\n    .maxAllowedVariationsPerKnot(10)  // Maximum number of variations (edges) per knot\n    .maxAllowedConditionsPerEdge(10)  // Maximum number of conditions per edge\n    .mutualExclusivitySettingTurnedOn(false)  // Whether edge conditions must be mutually exclusive\n    .build();\n</code></pre> <p>Key properties include:</p> <ul> <li>maxAllowedVariationsPerKnot: Limits the number of outgoing edges from a knot</li> <li>maxAllowedConditionsPerEdge: Limits the number of conditions on an edge</li> <li>mutualExclusivitySettingTurnedOn: When true, ensures that at most one edge's conditions can match for any given context</li> </ul>"},{"location":"usage/creating-bonsai.html#id-generation","title":"ID Generation","text":"<p>The <code>BonsaiIdGenerator</code> determines how IDs are generated for knots and edges:</p> <pre><code>// Or create a custom ID generator\nBonsaiIdGenerator customGenerator = new BonsaiIdGenerator() {\n    @Override\n    public String generateId() {\n        return \"custom-\" + System.currentTimeMillis();\n    }\n};\n</code></pre>"},{"location":"usage/creating-bonsai.html#storage-implementations","title":"Storage Implementations","text":"<p>Bonsai requires three storage implementations:</p> <ol> <li>KnotStore: Stores knot data</li> <li>EdgeStore: Stores edge data</li> <li>KeyTreeStore: Stores mappings between keys and root knots</li> </ol>"},{"location":"usage/creating-bonsai.html#in-memory-storage","title":"In-Memory Storage","text":"<p>For development or simple applications, you can use the in-memory implementations:</p> <pre><code>KnotStore knotStore = new InMemoryKnotStore();\nEdgeStore edgeStore = new InMemoryEdgeStore();\nKeyTreeStore keyTreeStore = new InMemoryKeyTreeStore();\n</code></pre>"},{"location":"usage/creating-bonsai.html#custom-storage-implementations","title":"Custom Storage Implementations","text":"<p>For production use, you'll likely want to implement custom storage backends. You should definitely go through the Storage section for more details. Here's an example Redis-based knot store:</p> <pre><code>// Example Redis-based knot store\npublic class RedisKnotStore implements KnotStore {\n    private final RedisClient redisClient;\n\n    public RedisKnotStore(RedisClient redisClient) {\n        this.redisClient = redisClient;\n    }\n\n    @Override\n    public Knot getKnot(String knotId) {\n        String json = redisClient.get(\"knot:\" + knotId);\n        return json != null ? deserialize(json, Knot.class) : null;\n    }\n\n    @Override\n    public void putKnot(Knot knot) {\n        redisClient.set(\"knot:\" + knot.getId(), serialize(knot));\n    }\n\n    // Implement other methods...\n}\n</code></pre>"},{"location":"usage/creating-bonsai.html#type-parameters","title":"Type Parameters","text":"<p>Bonsai is a generic class that can be parameterized with the type of context you'll be using:</p> <pre><code>// Using the default Context class\nBonsai&lt;Context&gt; bonsai = BonsaiBuilder.builder()\n    // ... configuration ...\n    .build();\n\n// Using a custom Context subclass\nBonsai&lt;UserContext&gt; bonsai = BonsaiBuilder.builder()\n    // ... configuration ...\n    .build();\n</code></pre>"},{"location":"usage/creating-bonsai.html#complete-example","title":"Complete Example","text":"<p>Here's a complete example of creating a Bonsai instance with custom configuration:</p> <pre><code>// Create a Bonsai instance with custom configuration\nBonsai&lt;UserContext&gt; bonsai = BonsaiBuilder.builder()\n    .withBonsaiProperties(\n        BonsaiProperties.builder()\n            .maxAllowedVariationsPerKnot(20)\n            .maxAllowedConditionsPerEdge(15)\n            .mutualExclusivitySettingTurnedOn(true)\n            .build())\n    .withEdgeStore(new RedisEdgeStore(redisClient))\n    .withKeyTreeStore(new RedisKeyTreeStore(redisClient))\n    .withKnotStore(new RedisKnotStore(redisClient))\n    .build();\n</code></pre>"},{"location":"usage/creating-bonsai.html#best-practices","title":"Best Practices","text":"<ul> <li>Choose appropriate limits: Set <code>maxAllowedVariationsPerKnot</code> and <code>maxAllowedConditionsPerEdge</code> based on your application's needs</li> <li>Consider mutual exclusivity: Enable <code>mutualExclusivitySettingTurnedOn</code> if you want to ensure deterministic behavior</li> <li>Use meaningful IDs: Consider a custom ID generator that produces readable IDs</li> <li>Select the right storage: Use in-memory storage for development and testing, but implement persistent storage for production</li> <li>Create a singleton: In most applications, you'll want to create a single Bonsai instance and reuse it</li> </ul>"},{"location":"usage/delta-operations.html","title":"Delta Operations","text":"<p>The Knot/Edge and Tree operations are useful for granular independent operations. However, a more practical way to make changes, would be through a series of related operations that need to be applied together. Imagine this happening  through a UI where all changes are first drafted and applied in one go. Delta operations allow you to make batch changes to the Bonsai tree structure in a single operation. This is useful when you need to make multiple related changes and want to ensure consistency. This guide explains how to use delta operations effectively.</p> <p>Note</p> <p>Delta operations are not Atomic. The operations get applied one by one across the three storage interfaces. As you might have realized, atomicity depends on type of databases used. If an error occurs during the application of delta operations,  the tree may be left in an inconsistent state. It is up to the application to handle errors and revert changes if needed.</p>"},{"location":"usage/delta-operations.html#understanding-delta-operations","title":"Understanding Delta Operations","text":"<p>Delta operations are a way to apply a series of changes to a tree structure as a single unit of work. They provide several benefits:</p> <ul> <li>Drafting Changes: Allows you to draft a series of changes before applying them</li> <li>Auditability: Changes can be tracked and potentially reverted</li> <li>Efficiency: Multiple changes can be applied in a single operation</li> </ul>"},{"location":"usage/delta-operations.html#types-of-delta-operations","title":"Types of Delta Operations","text":"<p>Bonsai supports three types of delta operations:</p> <ul> <li>KEY_MAPPING_DELTA: Operations related to key mappings</li> <li>KNOT_DELTA: Operations related to Knots</li> <li>EDGE_DELTA: Operations related to Edges</li> </ul> <p>Each operation type has its own specific class and builder pattern.</p>"},{"location":"usage/delta-operations.html#creating-delta-operations","title":"Creating Delta Operations","text":"<p>You can create delta operations using the specific operation builders or constructors:</p> <pre><code>// Create a knot delta operation using builder\nKnot knot = Knot.builder()\n    .id(\"knotId\")\n    .knotData(ValuedKnotData.stringValue(\"Sample value\"))\n    .build();\n\nKnotDeltaOperation knotOperation = KnotDeltaOperation.builder()\n    .knot(knot)\n    .build();\n\n// Or using constructor\nKnotDeltaOperation knotOp = new KnotDeltaOperation(knot);\n\n// Create a key mapping delta operation using builder\nKeyMappingDeltaOperation mappingOperation = KeyMappingDeltaOperation.builder()\n    .keyId(\"newKey\")\n    .knotId(\"generatedKnotId\")\n    .build();\n\n// Or using constructor\nKeyMappingDeltaOperation mappingOp = new KeyMappingDeltaOperation(\"newKey\", \"generatedKnotId\");\n\n// Create an edge delta operation using builder\nEdge edge = Edge.builder()\n    .edgeIdentifier(new EdgeIdentifier(\"edgeId\", 1, 1))\n    .knotId(\"targetKnotId\")\n    .filter(EqualsFilter.builder().field(\"userId\").value(\"U1\").build())\n    .build();\n\nEdgeDeltaOperation edgeOperation = EdgeDeltaOperation.builder()\n    .edge(edge)\n    .build();\n\n// Or using constructor\nEdgeDeltaOperation edgeOp = new EdgeDeltaOperation(edge);\n</code></pre>"},{"location":"usage/delta-operations.html#applying-delta-operations","title":"Applying Delta Operations","text":"<p>To apply a list of delta operations, use the <code>applyDeltaOperations</code> method:</p> <pre><code>// Create a list of delta operations\nList&lt;DeltaOperation&gt; operations = new ArrayList&lt;&gt;();\noperations.add(createKnotOp);\noperations.add(createMappingOp);\n\n// Apply the delta operations\nTreeKnotState result = bonsai.applyDeltaOperations(\"rootKey\", operations);\n\n// The result contains the updated tree and revert operations\nTreeKnot updatedTree = result.getTreeKnot();\nList&lt;DeltaOperation&gt; revertOperations = result.getRevertDeltaOperations();\n</code></pre> <p>The <code>applyDeltaOperations</code> method returns a <code>TreeKnotState</code> object that contains:</p> <ul> <li>The updated tree structure (<code>TreeKnot</code>)</li> <li>A list of operations that can be used to revert the changes (<code>getDeltaOperationsToPreviousState()</code>)</li> </ul>"},{"location":"usage/delta-operations.html#preview-vs-apply-operations","title":"Preview vs Apply Operations","text":"<p>Bonsai provides two methods for working with delta operations:</p> <ul> <li><code>getCompleteTreeWithDeltaOperations()</code>: Preview changes without persisting them to storage</li> <li><code>applyDeltaOperations()</code>: Apply changes and persist them to storage</li> </ul> <pre><code>// Preview changes without persisting\nTreeKnotState preview = bonsai.getCompleteTreeWithDeltaOperations(\"rootKey\", operations);\n\n// Apply and persist changes\nTreeKnotState result = bonsai.applyDeltaOperations(\"rootKey\", operations);\n</code></pre>"},{"location":"usage/delta-operations.html#example-creating-a-complete-tree-with-delta-operations","title":"Example: Creating a Complete Tree with Delta Operations","text":"<p>Here's an example of using delta operations to create a complete tree structure:</p> <pre><code>// Create a list of delta operations\nList&lt;DeltaOperation&gt; operations = new ArrayList&lt;&gt;();\n\n// Create the leaf knots\nKnot eligibleKnot = Knot.builder()\n    .id(\"eligibleKnot\")\n    .knotData(ValuedKnotData.builder().booleanValue(true).build())\n    .properties(Map.of(\"description\", \"User is eligible\"))\n    .build();\n\noperations.add(KnotDeltaOperation.builder()\n    .knot(eligibleKnot)\n    .build());\n\nKnot ineligibleKnot = Knot.builder()\n    .id(\"ineligibleKnot\")\n    .knotData(ValuedKnotData.builder().booleanValue(false).build())\n    .properties(Map.of(\"description\", \"User is ineligible\"))\n    .build();\n\noperations.add(KnotDeltaOperation.builder()\n    .knot(ineligibleKnot)\n    .build());\n\n// Create the root knot\nKnot rootKnot = Knot.builder()\n    .id(\"rootKnot\")\n    .knotData(ValuedKnotData.builder().build())\n    .properties(Map.of(\"description\", \"User eligibility decision point\"))\n    .build();\n\noperations.add(KnotDeltaOperation.builder()\n    .knot(rootKnot)\n    .build());\n\n// Create the edges\nEdge edge1 = Edge.builder()\n    .id(\"edge1\")\n    .sourceKnotId(\"rootKnot\")\n    .targetKnotId(\"eligibleKnot\")\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.user.age\")\n            .operator(Operator.GREATER_THAN_EQUAL)\n            .value(18)\n            .build(),\n        Filter.builder()\n            .path(\"$.user.country\")\n            .operator(Operator.IN)\n            .value(List.of(\"US\", \"CA\", \"UK\"))\n            .build()\n    ))\n    .build();\n\noperations.add(EdgeDeltaOperation.builder()\n    .edge(edge1)\n    .build());\n\nEdge edge2 = Edge.builder()\n    .id(\"edge2\")\n    .sourceKnotId(\"rootKnot\")\n    .targetKnotId(\"ineligibleKnot\")\n    .filters(List.of())\n    .build();\n\noperations.add(EdgeDeltaOperation.builder()\n    .edge(edge2)\n    .build());\n\n// Create the key mapping\noperations.add(KeyMappingDeltaOperation.builder()\n    .keyId(\"userEligibility\")\n    .knotId(\"rootKnot\")\n    .build());\n\n// Apply the delta operations\nTreeKnotState result = bonsai.applyDeltaOperations(null, operations);\n</code></pre>"},{"location":"usage/delta-operations.html#example-updating-an-existing-tree-with-delta-operations","title":"Example: Updating an Existing Tree with Delta Operations","text":"<p>Here's an example of using delta operations to update an existing tree structure:</p> <pre><code>// Create a list of delta operations\nList&lt;DeltaOperation&gt; operations = new ArrayList&lt;&gt;();\n\n// Update a knot's data\nKnot updatedKnot = Knot.builder()\n    .id(\"eligibleKnot\")\n    .knotData(ValuedKnotData.builder().booleanValue(true).build())\n    .properties(Map.of(\"description\", \"User is eligible\", \"version\", 1L))\n    .build();\n\noperations.add(KnotDeltaOperation.builder()\n    .knot(updatedKnot)\n    .build());\n\n// Update an edge's filters\nEdge updatedEdge = Edge.builder()\n    .id(\"edge1\")\n    .sourceKnotId(\"rootKnot\")\n    .targetKnotId(\"eligibleKnot\")\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.user.age\")\n            .operator(Operator.GREATER_THAN_EQUAL)\n            .value(21)\n            .build(),\n        Filter.builder()\n            .path(\"$.user.country\")\n            .operator(Operator.IN)\n            .value(List.of(\"US\", \"CA\"))\n            .build()\n    ))\n    .properties(Map.of(\"version\", 1L))\n    .build();\n\noperations.add(EdgeDeltaOperation.builder()\n    .edge(updatedEdge)\n    .build());\n\n// Apply the delta operations\nTreeKnotState result = bonsai.applyDeltaOperations(\"userEligibility\", operations);\n</code></pre>"},{"location":"usage/delta-operations.html#reverting-delta-operations","title":"Reverting Delta Operations","text":"<p>The <code>applyDeltaOperations</code> method returns a list of operations that can be used to revert the changes:</p> <pre><code>// Apply delta operations\nTreeKnotState result = bonsai.applyDeltaOperations(\"userEligibility\", operations);\n\n// Get the revert operations\nList&lt;DeltaOperation&gt; revertOperations = result.getDeltaOperationsToPreviousState();\n\n// If needed, apply the revert operations to undo the changes\nTreeKnotState revertResult = bonsai.applyDeltaOperations(\"userEligibility\", revertOperations);\n</code></pre> <p>This allows you to implement undo functionality or rollback changes if needed.</p>"},{"location":"usage/delta-operations.html#error-handling","title":"Error Handling","text":"<p>Delta operations can throw various exceptions:</p> <pre><code>try {\n    TreeKnotState result = bonsai.applyDeltaOperations(\"userEligibility\", operations);\n} catch (BonsaiError e) {\n    if (e.getErrorCode() == BonsaiErrorCode.VERSION_MISMATCH) {\n        // Handle version mismatch error\n        System.err.println(\"Version mismatch: \" + e.getMessage());\n    } else if (e.getErrorCode() == BonsaiErrorCode.CYCLE_DETECTED) {\n        // Handle cycle detected error\n        System.err.println(\"Cycle detected: \" + e.getMessage());\n    } else {\n        // Handle other errors\n        throw e;\n    }\n}\n</code></pre>"},{"location":"usage/delta-operations.html#best-practices","title":"Best Practices","text":"<ul> <li>Group related changes: Include all related changes in a single delta operation</li> <li>Consider versioning: Include version information in update operations to prevent conflicts</li> <li>Handle errors appropriately: Be prepared to handle errors and potentially retry operations</li> <li>Use meaningful IDs: Use meaningful IDs for created Knots and Edges</li> <li>Test thoroughly: Test delta operations thoroughly to ensure they work as expected</li> <li>Consider transaction boundaries: Think about what constitutes a logical transaction in your application</li> <li>Use revert operations: Store revert operations for important changes to enable undo functionality</li> </ul>"},{"location":"usage/edge-operations.html","title":"Edge Operations","text":"<p>Bonsai provides a comprehensive set of operations for managing Edges (also called Variations) in the tree structure. These operations allow you to create, read, update, and delete Edges, as well as manage their properties and conditions.</p>"},{"location":"usage/edge-operations.html#creating-edges","title":"Creating Edges","text":""},{"location":"usage/edge-operations.html#create-an-edge-directly","title":"Create an Edge Directly","text":"<pre><code>// Create an Edge directly\nEdge edge = bonsai.createEdge(Edge.builder()\n    .id(\"customEdgeId\") // Optional, Bonsai can generate an ID\n    .knotId(\"targetKnotId\")\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.user.age\")\n            .operator(Operator.GREATER_THAN_EQUAL)\n            .value(18)\n            .build()\n    ))\n    .properties(Map.of(\"description\", \"Age verification edge\"))\n    .build());\n</code></pre>"},{"location":"usage/edge-operations.html#add-a-variation-to-a-knot","title":"Add a Variation to a Knot","text":"<pre><code>// Add a Variation to a Knot\nEdge edge = bonsai.addVariation(\"sourceKnotId\", Variation.builder()\n    .knotId(\"targetKnotId\")\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.user.age\")\n            .operator(Operator.GREATER_THAN_EQUAL)\n            .value(18)\n            .build(),\n        Filter.builder()\n            .path(\"$.user.country\")\n            .operator(Operator.IN)\n            .value(List.of(\"US\", \"CA\", \"UK\"))\n            .build()\n    ))\n    .build());\n</code></pre>"},{"location":"usage/edge-operations.html#reading-edges","title":"Reading Edges","text":""},{"location":"usage/edge-operations.html#check-if-an-edge-exists","title":"Check if an Edge Exists","text":"<pre><code>boolean exists = bonsai.containsEdge(\"edgeId\");\n</code></pre>"},{"location":"usage/edge-operations.html#get-an-edge-by-id","title":"Get an Edge by ID","text":"<pre><code>Edge edge = bonsai.getEdge(\"edgeId\");\n</code></pre>"},{"location":"usage/edge-operations.html#get-multiple-edges-by-ids","title":"Get Multiple Edges by IDs","text":"<pre><code>Set&lt;String&gt; edgeIds = Set.of(\"edge1\", \"edge2\", \"edge3\");\nMap&lt;String, Edge&gt; edges = bonsai.getAllEdges(edgeIds);\n</code></pre>"},{"location":"usage/edge-operations.html#get-edges-for-a-knot","title":"Get Edges for a Knot","text":"<pre><code>List&lt;Edge&gt; edges = bonsai.getEdgesForKnot(\"knotId\");\n</code></pre>"},{"location":"usage/edge-operations.html#updating-edges","title":"Updating Edges","text":""},{"location":"usage/edge-operations.html#update-a-variation","title":"Update a Variation","text":"<pre><code>// Update a Variation on a Knot\nEdge updatedEdge = bonsai.updateVariation(\"knotId\", \"edgeId\", Variation.builder()\n    .knotId(\"newTargetKnotId\")\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.user.age\")\n            .operator(Operator.GREATER_THAN_EQUAL)\n            .value(21)\n            .build()\n    ))\n    .build());\n</code></pre>"},{"location":"usage/edge-operations.html#update-an-edges-properties","title":"Update an Edge's Properties","text":"<pre><code>// Update an Edge's properties\nMap&lt;String, Object&gt; newProperties = new HashMap&lt;&gt;(edge.getProperties());\nnewProperties.put(\"lastUpdated\", System.currentTimeMillis());\nnewProperties.put(\"updatedBy\", \"user123\");\nnewProperties.put(\"version\", edge.getVersion());\n\nEdge oldEdge = bonsai.updateEdgeProperties(\"edgeId\", newProperties);\n</code></pre>"},{"location":"usage/edge-operations.html#deleting-edges","title":"Deleting Edges","text":""},{"location":"usage/edge-operations.html#delete-a-variation","title":"Delete a Variation","text":"<pre><code>// Delete a Variation (without recursive deletion)\nTreeEdge deletedEdge = bonsai.deleteVariation(\"knotId\", \"edgeId\", false);\n\n// Delete a Variation and all its children (recursive deletion)\nTreeEdge deletedEdge = bonsai.deleteVariation(\"knotId\", \"edgeId\", true);\n</code></pre> <p>The <code>deleteVariation</code> method returns a <code>TreeEdge</code> object representing the deleted subtree. This can be useful for auditing or potentially restoring the deleted structure.</p>"},{"location":"usage/edge-operations.html#unlink-a-variation","title":"Unlink a Variation","text":"<pre><code>// Unlink a Variation (remove the Edge but keep the target Knot)\nbonsai.unlinkVariation(\"knotId\", \"edgeId\");\n</code></pre>"},{"location":"usage/edge-operations.html#edge-ordering","title":"Edge Ordering","text":"<p>Edges on a Knot are evaluated in the order they are added. You can reorder Edges to change the evaluation priority:</p> <pre><code>// Reorder Edges on a Knot\nList&lt;String&gt; newOrder = List.of(\"edge3\", \"edge1\", \"edge2\");\nbonsai.reorderEdges(\"knotId\", newOrder);\n</code></pre>"},{"location":"usage/edge-operations.html#filter-operations","title":"Filter Operations","text":"<p>Filters (or conditions) define when an Edge should be followed during tree traversal. Here are some examples of creating filters:</p> <pre><code>// Equals filter\nFilter equalsFilter = Filter.builder()\n    .path(\"$.user.type\")\n    .operator(Operator.EQUALS)\n    .value(\"premium\")\n    .build();\n\n// Greater than filter\nFilter greaterThanFilter = Filter.builder()\n    .path(\"$.user.age\")\n    .operator(Operator.GREATER_THAN)\n    .value(18)\n    .build();\n\n// In filter (membership in a list)\nFilter inFilter = Filter.builder()\n    .path(\"$.user.country\")\n    .operator(Operator.IN)\n    .value(List.of(\"US\", \"CA\", \"UK\"))\n    .build();\n\n// Contains filter (substring match)\nFilter containsFilter = Filter.builder()\n    .path(\"$.user.email\")\n    .operator(Operator.CONTAINS)\n    .value(\"@example.com\")\n    .build();\n\n// Regex filter (pattern match)\nFilter regexFilter = Filter.builder()\n    .path(\"$.user.phone\")\n    .operator(Operator.REGEX)\n    .value(\"^\\\\+1-\\\\d{3}-\\\\d{3}-\\\\d{4}$\")\n    .build();\n</code></pre>"},{"location":"usage/edge-operations.html#error-handling","title":"Error Handling","text":"<p>Edge operations can throw various exceptions:</p> <ul> <li><code>BonsaiError.EDGE_ABSENT</code>: When trying to access a non-existent Edge</li> <li><code>BonsaiError.KNOT_ABSENT</code>: When referencing a non-existent Knot</li> <li><code>BonsaiError.CYCLE_DETECTED</code>: When an operation would create a cycle in the tree</li> <li><code>BonsaiError.MAX_CONDITIONS_EXCEEDED</code>: When adding too many conditions to an Edge</li> <li><code>BonsaiError.VARIATION_MUTUAL_EXCLUSIVITY_CONSTRAINT_ERROR</code>: When Edge conditions violate mutual exclusivity</li> </ul> <p>Example of handling errors:</p> <pre><code>try {\n    Edge edge = bonsai.getEdge(\"nonExistentEdgeId\");\n} catch (BonsaiError e) {\n    if (e.getErrorCode() == BonsaiErrorCode.EDGE_NOT_FOUND) {\n        // Handle edge not found error\n        System.err.println(\"Edge not found: \" + e.getMessage());\n    } else {\n        // Handle other errors\n        throw e;\n    }\n}\n</code></pre>"},{"location":"usage/edge-operations.html#best-practices","title":"Best Practices","text":"<ul> <li>Order Edges from most specific to most general</li> <li>Use a default Edge (with no filters) as the last Edge on a Knot to handle all remaining cases</li> <li>Keep filter conditions simple and focused</li> <li>Consider the performance impact of complex JsonPath expressions</li> <li>Use meaningful properties to document the purpose of each Edge</li> <li>Be mindful of the maximum number of conditions per Edge (configured in BonsaiProperties)</li> <li>Consider mutual exclusivity settings when designing Edge conditions</li> </ul>"},{"location":"usage/evaluating-trees.html","title":"Evaluating Trees","text":"<p>Evaluating trees is the process of traversing a Bonsai tree based on a context to retrieve the appropriate data. This guide explains how to create contexts, evaluate trees, and process the results.</p>"},{"location":"usage/evaluating-trees.html#creating-a-context","title":"Creating a Context","text":"<p>Before evaluating a tree, you need to create a Context object that contains the data needed to evaluate conditions on Edges:</p> <pre><code>// Create a Context from a JSON string\nString json = \"{\\\"user\\\": {\\\"age\\\": 25, \\\"country\\\": \\\"US\\\", \\\"type\\\": \\\"premium\\\"}}\";\nContext context = Context.builder()\n    .documentContext(JsonPath.parse(json))\n    .build();\n\n// Create a Context from an object\nUser user = new User(\"John\", 25, \"US\", \"premium\");\nContext context = Context.builder()\n    .documentContext(JsonPath.parse(user))\n    .build();\n\n// Create a Context with preferences\nMap&lt;String, Knot&gt; preferences = Map.of(\"homePageConfig\", customKnot);\nContext context = Context.builder()\n    .documentContext(JsonPath.parse(user))\n    .preferences(preferences)\n    .build();\n\n// Create a Context with metadata\nContext context = Context.builder()\n    .documentContext(JsonPath.parse(user))\n    .metadata(Map.of(\n        \"requestId\", UUID.randomUUID().toString(),\n        \"timestamp\", System.currentTimeMillis(),\n        \"source\", \"mobile-app\"\n    ))\n    .build();\n</code></pre>"},{"location":"usage/evaluating-trees.html#basic-evaluation","title":"Basic Evaluation","text":"<p>To evaluate a tree, you call the <code>evaluate</code> method with a key and a context:</p> <pre><code>// Evaluate the tree\nKeyNode result = bonsai.evaluate(\"userEligibility\", context);\n\n// Access the evaluation result\nBoolean isEligible = result.getValue().getBooleanValue();\nSystem.out.println(\"User is eligible: \" + isEligible); // true\n</code></pre>"},{"location":"usage/evaluating-trees.html#accessing-evaluation-results","title":"Accessing Evaluation Results","text":"<p>The result of an evaluation is a <code>KeyNode</code> object that reflects the structure of the KnotData in the final Knot reached during traversal:</p>"},{"location":"usage/evaluating-trees.html#value-results","title":"Value Results","text":"<p>For ValuedKnotData, you can access the primitive value using NodeUtils helper methods:</p> <pre><code>// String value\nString stringValue = NodeUtils.asString(result.getValue(), \"defaultValue\");\n\n// Boolean value\nBoolean booleanValue = NodeUtils.asBoolean(result.getValue(), false);\n\n// Number value\nDouble numberValue = NodeUtils.asNumber(result.getValue(), 1);\n\n// JSON value\nJsonNode jsonValue = NodeUtils.asJsonNode(result.getValue(), JsonNodeFactory.instance.objectNode());\n</code></pre>"},{"location":"usage/evaluating-trees.html#list-results","title":"List Results","text":"<p>For MultiKnotData, you can access the list of KeyNodes:</p> <pre><code>// Get the list of KeyNodes\nList&lt;KeyNode&gt; items = result.getKeyNodeList();\n\n// Process each item\nfor (KeyNode item : items) {\n    // Access the item's value\n    String value = NodeUtils.asString(item.getValue(), \"\");\n    System.out.println(\"Item value: \" + value);\n}\n</code></pre>"},{"location":"usage/evaluating-trees.html#map-results","title":"Map Results","text":"<p>For MapKnotData, you can access the map of string keys to KeyNodes:</p> <pre><code>// Get the map of KeyNodes\nMap&lt;String, KeyNode&gt; properties = result.getKeyNodeMap();\n\n// Access specific properties\nString name = NodeUtils.asString(properties.get(\"name\").getValue(), \"\");\nDouble age = NodeUtils.asString(properties.get(\"age\").getValue(), \"\");\nBoolean active = NodeUtils.asString(properties.get(\"active\").getValue(), \"\");\n\nSystem.out.println(\"User: \" + name + \", Age: \" + age + \", Active: \" + active);\n</code></pre>"},{"location":"usage/evaluating-trees.html#flat-evaluation","title":"Flat Evaluation","text":"<p>For debugging or visualization purposes, you can get a flat representation of the evaluated tree:</p> <pre><code>// Get a flat representation of the evaluated tree\nFlatTreeRepresentation flatTree = bonsai.evaluateFlat(\"userEligibility\", context);\n\n// Access the flat tree information\nString rootKnotId = flatTree.getRootKnotId();\nMap&lt;String, Knot&gt; knots = flatTree.getKnots();\nMap&lt;String, Edge&gt; edges = flatTree.getEdges();\nList&lt;String&gt; traversedEdgeIds = flatTree.getTraversedEdgeIds();\n</code></pre>"},{"location":"usage/evaluating-trees.html#contextual-preferences","title":"Contextual Preferences","text":"<p>The Context can include a <code>preferences</code> map, which maps keys to specific Knots. When evaluating a key, if the key is found in the preferences map, Bonsai will return the associated Knot directly, bypassing the normal tree traversal:</p> <pre><code>// Get a custom knot for a specific user\nKnot customHomePageKnot = bonsai.getKnot(\"custom-home-page\");\n\n// Create a context with preferences\nMap&lt;String, Knot&gt; preferences = Map.of(\"homePage\", customHomePageKnot);\nContext context = Context.builder()\n    .documentContext(JsonPath.parse(userData))\n    .preferences(preferences)\n    .build();\n\n// Evaluate the tree - will return the custom knot directly\nKeyNode result = bonsai.evaluate(\"homePage\", context);\n</code></pre> <p>This is useful for scenarios like user-specific overrides of default configurations.</p>"},{"location":"usage/evaluating-trees.html#custom-context-implementation","title":"Custom Context Implementation","text":"<p>You can create custom Context implementations for specific application needs:</p> <pre><code>public class UserContext extends Context {\n    private User user;\n\n    public UserContext(User user) {\n        super(JsonPath.parse(user));\n        this.user = user;\n    }\n\n    // Custom methods to access user data\n    public int getUserAge() {\n        return user.getAge();\n    }\n\n    public String getUserCountry() {\n        return user.getCountry();\n    }\n}\n\n// Create a custom context\nUser user = new User(\"John\", 25, \"US\", \"premium\");\nUserContext context = new UserContext(user);\n\n// Evaluate the tree with the custom context\nKeyNode result = bonsai.evaluate(\"userEligibility\", context);\n</code></pre>"},{"location":"usage/evaluating-trees.html#evaluation-process","title":"Evaluation Process","text":"<p>Understanding the evaluation process can help you design effective tree structures:</p> <ol> <li>Bonsai starts at the root Knot for the specified key</li> <li>For each Knot, it evaluates the Edges in order</li> <li>For each Edge, it evaluates all filters against the Context</li> <li>If all filters on an Edge evaluate to true, it follows that Edge to the target Knot</li> <li>If no Edge's filters match, the traversal stops at the current Knot</li> <li>The process continues until it reaches a Knot with no matching Edges</li> <li>The final Knot's data is returned as the result</li> </ol>"},{"location":"usage/evaluating-trees.html#error-handling","title":"Error Handling","text":"<p>Evaluation can throw various exceptions:</p> <pre><code>try {\n    KeyNode result = bonsai.evaluate(\"nonExistentKey\", context);\n} catch (BonsaiError e) {\n    if (e.getErrorCode() == BonsaiErrorCode.KEY_NOT_FOUND) {\n        // Handle key not found error\n        System.err.println(\"Key not found: \" + e.getMessage());\n    } else {\n        // Handle other errors\n        throw e;\n    }\n}\n</code></pre>"},{"location":"usage/evaluating-trees.html#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Context Size: Large Context objects can impact performance</li> <li>Tree Depth: Deep trees require more traversal steps</li> <li>Filter Complexity: Complex JsonPath expressions can be expensive to evaluate</li> <li>Caching: Consider caching evaluation results for frequently used keys and contexts</li> </ul>"},{"location":"usage/evaluating-trees.html#best-practices","title":"Best Practices","text":"<ul> <li>Structure your Context data in a way that makes JsonPath expressions simple and intuitive</li> <li>Use consistent data structures across similar contexts for easier maintenance</li> <li>Document the expected Context structure for each key to ensure proper usage</li> <li>Consider performance implications of large Context objects</li> <li>Handle evaluation errors appropriately in your application</li> <li>Use preferences judiciously to avoid bypassing the rule engine unnecessarily</li> </ul>"},{"location":"usage/installation.html","title":"Installation","text":"<p>Adding Bonsai to your Java project is straightforward. This guide covers the different ways to include Bonsai as a dependency in your project.</p>"},{"location":"usage/installation.html#maven","title":"Maven","text":"<p>To add Bonsai to your Maven project, include the following dependency in your <code>pom.xml</code> file:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.phonepe.commons&lt;/groupId&gt;\n    &lt;artifactId&gt;bonsai-core&lt;/artifactId&gt;\n    &lt;version&gt;${bonsai.version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Replace <code>${bonsai.version}</code> with the latest version of Bonsai. You can find the latest version on Maven Central.</p> <p>If you need additional modules, you can include them as separate dependencies:</p> <pre><code>&lt;!-- For JSON evaluation support --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.phonepe.commons&lt;/groupId&gt;\n    &lt;artifactId&gt;bonsai-json-eval&lt;/artifactId&gt;\n    &lt;version&gt;${bonsai.version}&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;!-- For condition support --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.phonepe.commons&lt;/groupId&gt;\n    &lt;artifactId&gt;bonsai-conditions&lt;/artifactId&gt;\n    &lt;version&gt;${bonsai.version}&lt;/version&gt;\n&lt;/dependency&gt;\n\n&lt;!-- For model classes --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.phonepe.commons&lt;/groupId&gt;\n    &lt;artifactId&gt;bonsai-models&lt;/artifactId&gt;\n    &lt;version&gt;${bonsai.version}&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"usage/installation.html#gradle","title":"Gradle","text":"<p>To add Bonsai to your Gradle project, include the following dependency in your <code>build.gradle</code> file:</p> <pre><code>implementation 'com.phonepe.commons:bonsai-core:${bonsai.version}'\n</code></pre> <p>Replace <code>${bonsai.version}</code> with the latest version of Bonsai.</p> <p>For additional modules:</p> <pre><code>// For JSON evaluation support\nimplementation 'com.phonepe.commons:bonsai-json-eval:${bonsai.version}'\n\n// For condition support\nimplementation 'com.phonepe.commons:bonsai-conditions:${bonsai.version}'\n\n// For model classes\nimplementation 'com.phonepe.commons:bonsai-models:${bonsai.version}'\n</code></pre>"},{"location":"usage/installation.html#building-from-source","title":"Building from Source","text":"<p>If you prefer to build Bonsai from source:</p> <ol> <li> <p>Clone the repository:    <pre><code>git clone https://github.com/PhonePe/bonsai.git\n</code></pre></p> </li> <li> <p>Navigate to the project directory:    <pre><code>cd bonsai\n</code></pre></p> </li> <li> <p>Build the project:    <pre><code>mvn clean install\n</code></pre></p> </li> <li> <p>The built artifacts will be available in your local Maven repository.</p> </li> </ol>"},{"location":"usage/installation.html#dependencies","title":"Dependencies","text":"<p>Bonsai has the following key dependencies:</p> <ul> <li>Java 17 or higher</li> <li>JsonPath for JSON path evaluation</li> <li>Query-DSL for condition evaluation</li> </ul> <p>These dependencies will be automatically included when you add Bonsai to your project.</p>"},{"location":"usage/installation.html#verifying-installation","title":"Verifying Installation","text":"<p>To verify that Bonsai is correctly installed, you can create a simple test class:</p> <pre><code>import com.phonepe.commons.bonsai.core.Bonsai;\nimport com.phonepe.commons.bonsai.core.vital.BonsaiBuilder;\nimport com.phonepe.commons.bonsai.core.vital.BonsaiProperties;\n\npublic class BonsaiTest {\n    public static void main(String[] args) {\n        // Create a Bonsai instance\n        Bonsai&lt;?&gt; bonsai = BonsaiBuilder.builder()\n            .withBonsaiProperties(BonsaiProperties.builder().build())\n            .build();\n\n        System.out.println(\"Bonsai instance created successfully: \" + bonsai);\n    }\n}\n</code></pre> <p>If the code compiles and runs without errors, Bonsai is correctly installed.</p>"},{"location":"usage/knot-operations.html","title":"Knot Operations","text":"<p>Bonsai provides a comprehensive set of operations for managing Knots in the tree structure. These operations allow you to create, read, update, and delete Knots, as well as manage their properties and data.</p>"},{"location":"usage/knot-operations.html#creating-knots","title":"Creating Knots","text":""},{"location":"usage/knot-operations.html#create-a-knot-with-data","title":"Create a Knot with Data","text":"<pre><code>// Create a Knot with a string value\nKnot stringKnot = bonsai.createKnot(\n    ValuedKnotData.builder().stringValue(\"Hello, World!\").build(),\n    Map.of(\"description\", \"A simple string knot\")\n);\n\n// Create a Knot with a boolean value\nKnot booleanKnot = bonsai.createKnot(\n    ValuedKnotData.builder().booleanValue(true).build(),\n    Map.of(\"description\", \"A boolean knot\")\n);\n\n// Create a Knot with a number value\nKnot numberKnot = bonsai.createKnot(\n    ValuedKnotData.builder().numberValue(42.5).build(),\n    Map.of(\"description\", \"A number knot\")\n);\n\n// Create a Knot with references to other Knots (Map)\nKnot mapKnot = bonsai.createKnot(\n    MapKnotData.builder()\n        .keyMapping(Map.of(\n            \"string\", stringKnot.getId(),\n            \"boolean\", booleanKnot.getId(),\n            \"number\", numberKnot.getId()\n        ))\n        .build(),\n    Map.of(\"description\", \"A map knot\")\n);\n\n// Create a Knot with references to other Knots (List)\nKnot listKnot = bonsai.createKnot(\n    MultiKnotData.builder()\n        .knotIds(List.of(stringKnot.getId(), booleanKnot.getId(), numberKnot.getId()))\n        .build(),\n    Map.of(\"description\", \"A list knot\")\n);\n</code></pre>"},{"location":"usage/knot-operations.html#reading-knots","title":"Reading Knots","text":""},{"location":"usage/knot-operations.html#check-if-a-knot-exists","title":"Check if a Knot Exists","text":"<pre><code>boolean exists = bonsai.containsKnot(\"knotId\");\n</code></pre>"},{"location":"usage/knot-operations.html#get-a-knot-by-id","title":"Get a Knot by ID","text":"<pre><code>Knot knot = bonsai.getKnot(\"knotId\");\n</code></pre>"},{"location":"usage/knot-operations.html#get-multiple-knots-by-ids","title":"Get Multiple Knots by IDs","text":"<pre><code>Set&lt;String&gt; knotIds = Set.of(\"knot1\", \"knot2\", \"knot3\");\nMap&lt;String, Knot&gt; knots = bonsai.getAllKnots(knotIds);\n</code></pre>"},{"location":"usage/knot-operations.html#updating-knots","title":"Updating Knots","text":""},{"location":"usage/knot-operations.html#update-a-knots-data","title":"Update a Knot's Data","text":"<pre><code>// Update a Knot's data\nKnot oldKnot = bonsai.updateKnotData(\n    \"knotId\",\n    ValuedKnotData.builder().stringValue(\"Updated value\").build(),\n    Map.of(\"description\", \"Updated knot\", \"version\", knot.getVersion())\n);\n</code></pre> <p>The <code>updateKnotData</code> method returns the previous version of the Knot before the update.</p>"},{"location":"usage/knot-operations.html#update-a-knots-properties","title":"Update a Knot's Properties","text":"<pre><code>// Update a Knot's properties\nMap&lt;String, Object&gt; newProperties = new HashMap&lt;&gt;(knot.getProperties());\nnewProperties.put(\"lastUpdated\", System.currentTimeMillis());\nnewProperties.put(\"updatedBy\", \"user123\");\nnewProperties.put(\"version\", knot.getVersion());\n\nKnot oldKnot = bonsai.updateKnotProperties(\"knotId\", newProperties);\n</code></pre>"},{"location":"usage/knot-operations.html#deleting-knots","title":"Deleting Knots","text":""},{"location":"usage/knot-operations.html#delete-a-knot","title":"Delete a Knot","text":"<pre><code>// Delete a Knot (without recursive deletion)\nTreeKnot deletedTree = bonsai.deleteKnot(\"knotId\", false);\n\n// Delete a Knot and all its children (recursive deletion)\nTreeKnot deletedTree = bonsai.deleteKnot(\"knotId\", true);\n</code></pre> <p>The <code>deleteKnot</code> method returns a <code>TreeKnot</code> object representing the deleted subtree. This can be useful for auditing or potentially restoring the deleted structure.</p>"},{"location":"usage/knot-operations.html#managing-variations-edges","title":"Managing Variations (Edges)","text":""},{"location":"usage/knot-operations.html#add-a-variation-to-a-knot","title":"Add a Variation to a Knot","text":"<pre><code>// Add a Variation to a Knot\nEdge edge = bonsai.addVariation(\"knotId\", Variation.builder()\n    .knotId(\"targetKnotId\")\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.user.age\")\n            .operator(Operator.GREATER_THAN_EQUAL)\n            .value(18)\n            .build()\n    ))\n    .build());\n</code></pre>"},{"location":"usage/knot-operations.html#update-a-variation-on-a-knot","title":"Update a Variation on a Knot","text":"<pre><code>// Update a Variation on a Knot\nEdge updatedEdge = bonsai.updateVariation(\"knotId\", \"edgeId\", Variation.builder()\n    .knotId(\"newTargetKnotId\")\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.user.age\")\n            .operator(Operator.GREATER_THAN_EQUAL)\n            .value(21)\n            .build()\n    ))\n    .build());\n</code></pre>"},{"location":"usage/knot-operations.html#delete-a-variation-from-a-knot","title":"Delete a Variation from a Knot","text":"<pre><code>// Delete a Variation (without recursive deletion)\nTreeEdge deletedEdge = bonsai.deleteVariation(\"knotId\", \"edgeId\", false);\n\n// Delete a Variation and all its children (recursive deletion)\nTreeEdge deletedEdge = bonsai.deleteVariation(\"knotId\", \"edgeId\", true);\n</code></pre>"},{"location":"usage/knot-operations.html#unlink-a-variation","title":"Unlink a Variation","text":"<pre><code>// Unlink a Variation (remove the Edge but keep the target Knot)\nbonsai.unlinkVariation(\"knotId\", \"edgeId\");\n</code></pre>"},{"location":"usage/knot-operations.html#error-handling","title":"Error Handling","text":"<p>Knot operations can throw various exceptions:</p> <ul> <li><code>BonsaiError.KNOT_NOT_FOUND</code>: When trying to access a non-existent Knot</li> <li><code>BonsaiError.VERSION_MISMATCH</code>: When trying to update a Knot with an outdated version</li> <li><code>BonsaiError.CYCLE_DETECTED</code>: When an operation would create a cycle in the tree</li> <li><code>BonsaiError.MAX_VARIATIONS_EXCEEDED</code>: When adding too many variations to a Knot</li> </ul> <p>Example of handling errors:</p> <pre><code>try {\n    Knot knot = bonsai.getKnot(\"nonExistentKnotId\");\n} catch (BonsaiError e) {\n    if (e.getErrorCode() == BonsaiErrorCode.KNOT_NOT_FOUND) {\n        // Handle knot not found error\n        System.err.println(\"Knot not found: \" + e.getMessage());\n    } else {\n        // Handle other errors\n        throw e;\n    }\n}\n</code></pre>"},{"location":"usage/knot-operations.html#best-practices","title":"Best Practices","text":"<ul> <li>Use meaningful IDs or let Bonsai generate them for you</li> <li>Include descriptive properties to make Knots easier to understand and manage</li> <li>Consider versioning implications when updating Knots</li> <li>Use recursive deletion carefully, as it can remove large portions of the tree</li> <li>Handle errors appropriately to maintain tree consistency</li> </ul>"},{"location":"usage/tree-operations.html","title":"Tree Operations","text":"<p>Bonsai provides a comprehensive set of operations for managing the overall tree structure and key mappings. These operations allow you to create, read, update, and delete tree structures, as well as evaluate trees against a context.</p>"},{"location":"usage/tree-operations.html#key-mapping-operations","title":"Key Mapping Operations","text":""},{"location":"usage/tree-operations.html#check-if-a-key-mapping-exists","title":"Check if a Key Mapping Exists","text":"<pre><code>boolean exists = bonsai.containsKey(\"key\");\n</code></pre>"},{"location":"usage/tree-operations.html#create-a-mapping-between-a-key-and-an-existing-knot","title":"Create a Mapping Between a Key and an Existing Knot","text":"<pre><code>// Create a mapping between a key and an existing Knot\nKnot knot = bonsai.createMapping(\"key\", \"knotId\");\n</code></pre>"},{"location":"usage/tree-operations.html#create-a-new-knot-and-map-it-to-a-key","title":"Create a New Knot and Map it to a Key","text":"<pre><code>// Create a new Knot with data and map it to a key\nKnot knot = bonsai.createMapping(\"key\", \n    ValuedKnotData.builder().stringValue(\"Hello, World!\").build(),\n    Map.of(\"description\", \"A simple string knot\")\n);\n</code></pre>"},{"location":"usage/tree-operations.html#get-the-knot-id-for-a-key","title":"Get the Knot ID for a Key","text":"<pre><code>// Get the Knot ID for a key\nString knotId = bonsai.getMapping(\"key\");\n</code></pre>"},{"location":"usage/tree-operations.html#remove-a-key-mapping","title":"Remove a Key Mapping","text":"<pre><code>// Remove a key mapping (does not delete the Knot)\nKnot unmappedKnot = bonsai.removeMapping(\"key\");\n</code></pre>"},{"location":"usage/tree-operations.html#tree-structure-operations","title":"Tree Structure Operations","text":""},{"location":"usage/tree-operations.html#get-the-complete-tree-for-a-key","title":"Get the Complete Tree for a Key","text":"<pre><code>// Get the complete tree for a key\nTreeKnot tree = bonsai.getCompleteTree(\"key\");\n</code></pre> <p>The <code>TreeKnot</code> object represents the entire tree structure, including all Knots and Edges reachable from the root Knot.</p>"},{"location":"usage/tree-operations.html#create-a-complete-tree-from-a-treeknot-structure","title":"Create a Complete Tree from a TreeKnot Structure","text":"<pre><code>// Create a complete tree from a TreeKnot structure\nKnot rootKnot = bonsai.createCompleteTree(treeKnot);\n</code></pre> <p>This operation is useful for importing tree structures or restoring trees from a backup.</p>"},{"location":"usage/tree-operations.html#tree-evaluation-operations","title":"Tree Evaluation Operations","text":""},{"location":"usage/tree-operations.html#evaluate-a-key-against-a-context","title":"Evaluate a Key Against a Context","text":"<pre><code>// Create a context for evaluation\nContext context = Context.builder()\n    .documentContext(JsonPath.parse(\"{\\\"user\\\": {\\\"age\\\": 25, \\\"country\\\": \\\"US\\\"}}\"))\n    .build();\n\n// Evaluate the tree\nKeyNode result = bonsai.evaluate(\"key\", context);\n</code></pre> <p>The <code>KeyNode</code> object represents the result of the evaluation, containing the data from the final Knot reached during traversal.</p>"},{"location":"usage/tree-operations.html#get-a-flat-representation-of-the-evaluated-tree","title":"Get a Flat Representation of the Evaluated Tree","text":"<pre><code>// Get a flat representation of the evaluated tree\nFlatTreeRepresentation flatTree = bonsai.evaluateFlat(\"key\", context);\n</code></pre> <p>The <code>FlatTreeRepresentation</code> object provides a flattened view of the evaluation result, which can be useful for debugging or visualization.</p>"},{"location":"usage/tree-operations.html#delta-operations","title":"Delta Operations","text":"<p>Delta operations allow you to make batch changes to the tree structure. This is useful when you need to make multiple related changes atomically.</p>"},{"location":"usage/tree-operations.html#apply-delta-operations","title":"Apply Delta Operations","text":"<pre><code>// Create a list of delta operations\nList&lt;DeltaOperation&gt; operations = new ArrayList&lt;&gt;();\n\n// Add an operation to create a new knot\noperations.add(DeltaOperation.builder()\n    .operationType(OperationType.CREATE_KNOT)\n    .knotData(ValuedKnotData.builder().stringValue(\"New value\").build())\n    .properties(Map.of(\"description\", \"New knot\"))\n    .build());\n\n// Add an operation to create a mapping\noperations.add(DeltaOperation.builder()\n    .operationType(OperationType.CREATE_MAPPING)\n    .key(\"newKey\")\n    .knotId(\"generatedKnotId\") // ID from the previous operation\n    .build());\n\n// Apply the delta operations\nTreeKnotState result = bonsai.applyDeltaOperations(\"rootKey\", operations);\n\n// The result contains the updated tree and revert operations\nTreeKnot updatedTree = result.getTreeKnot();\nList&lt;DeltaOperation&gt; revertOperations = result.getRevertDeltaOperations();\n</code></pre>"},{"location":"usage/tree-operations.html#types-of-delta-operations","title":"Types of Delta Operations","text":"<p>Bonsai supports several types of delta operations:</p> <ul> <li><code>CREATE_KNOT</code>: Create a new Knot</li> <li><code>UPDATE_KNOT_DATA</code>: Update a Knot's data</li> <li><code>UPDATE_KNOT_PROPERTIES</code>: Update a Knot's properties</li> <li><code>DELETE_KNOT</code>: Delete a Knot</li> <li><code>CREATE_EDGE</code>: Create a new Edge</li> <li><code>UPDATE_EDGE</code>: Update an Edge</li> <li><code>DELETE_EDGE</code>: Delete an Edge</li> <li><code>CREATE_MAPPING</code>: Create a key mapping</li> <li><code>UPDATE_MAPPING</code>: Update a key mapping</li> <li><code>DELETE_MAPPING</code>: Delete a key mapping</li> </ul>"},{"location":"usage/tree-operations.html#tree-validation","title":"Tree Validation","text":"<p>Bonsai provides validation capabilities to ensure the integrity of tree structures:</p> <pre><code>// Create a validator\nBonsaiTreeValidator validator = new ComponentBonsaiTreeValidator();\n\n// Validate a tree structure\nValidationResult result = validator.validate(treeKnot);\n\nif (!result.isValid()) {\n    // Handle validation errors\n    List&lt;ValidationError&gt; errors = result.getErrors();\n    for (ValidationError error : errors) {\n        System.err.println(error.getMessage());\n    }\n}\n</code></pre>"},{"location":"usage/tree-operations.html#error-handling","title":"Error Handling","text":"<p>Tree operations can throw various exceptions:</p> <ul> <li><code>BonsaiError.KEY_NOT_FOUND</code>: When trying to access a non-existent key</li> <li><code>BonsaiError.CYCLE_DETECTED</code>: When an operation would create a cycle in the tree</li> <li><code>BonsaiError.TREE_ALREADY_EXIST</code>: When trying to create a tree that already exists</li> <li><code>BonsaiError.INVALID_TREE_STRUCTURE</code>: When a tree structure is invalid</li> </ul> <p>Example of handling errors:</p> <pre><code>try {\n    String knotId = bonsai.getMapping(\"nonExistentKey\");\n} catch (BonsaiError e) {\n    if (e.getErrorCode() == BonsaiErrorCode.KEY_NOT_FOUND) {\n        // Handle key not found error\n        System.err.println(\"Key not found: \" + e.getMessage());\n    } else {\n        // Handle other errors\n        throw e;\n    }\n}\n</code></pre>"},{"location":"usage/tree-operations.html#best-practices","title":"Best Practices","text":"<ul> <li>Use meaningful key names that reflect the purpose of the tree</li> <li>Organize related trees with consistent key naming conventions</li> <li>Consider using key hierarchies (e.g., \"feature.subfeature.config\")</li> <li>Use delta operations for related changes to maintain consistency</li> <li>Validate tree structures before using them in production</li> <li>Handle errors appropriately to maintain tree integrity</li> <li>Document the expected Context structure for each key to ensure proper usage</li> </ul>"},{"location":"use-cases/index.html","title":"Real-World Use Cases","text":"<p>Bonsai is a versatile rule engine that can be applied to a wide range of real-world use cases. This section explores some common applications of Bonsai and provides examples of how to implement them.</p>"},{"location":"use-cases/index.html#topics-covered","title":"Topics Covered","text":"<ul> <li>Feature Flagging System: Learn how to implement a sophisticated feature flagging system</li> <li>Dynamic Pricing Rules: Explore how to create complex pricing rules with nested conditions</li> </ul>"},{"location":"use-cases/index.html#why-use-bonsai-for-these-use-cases","title":"Why Use Bonsai for These Use Cases?","text":"<p>Bonsai offers several advantages for implementing these use cases:</p> <ul> <li>Flexibility: Bonsai's tree-based structure can represent complex decision logic</li> <li>Dynamic Updates: Rules can be updated without code changes</li> <li>Conditional Logic: Conditions can be based on various factors</li> <li>Nested Structures: Complex hierarchical rules can be represented</li> <li>Performance: Efficient evaluation for high-throughput scenarios</li> <li>Versioning: Changes can be tracked and potentially reverted</li> </ul>"},{"location":"use-cases/index.html#common-patterns","title":"Common Patterns","text":"<p>Across these use cases, you'll notice some common patterns:</p> <ul> <li>Decision Trees: Using tree structures to represent decision logic</li> <li>Conditional Branching: Using conditions to determine which path to follow</li> <li>Default Cases: Providing fallback options when no conditions match</li> <li>Nested Structures: Using nested structures to represent complex hierarchies</li> <li>Dynamic Updates: Updating rules without code changes</li> </ul>"},{"location":"use-cases/index.html#getting-started","title":"Getting Started","text":"<p>To get started with these use cases, you should first:</p> <ol> <li>Understand the basic concepts of Bonsai</li> <li>Set up a Bonsai instance with appropriate configuration</li> <li>Design your tree structure based on your specific requirements</li> <li>Implement the tree structure using Bonsai's API</li> <li>Test your implementation with various inputs</li> </ol>"},{"location":"use-cases/dynamic-pricing.html","title":"Dynamic Pricing Rules","text":"<p>Dynamic pricing is a strategy where prices are adjusted based on various factors such as demand, supply, time, customer segments, and more. Bonsai's tree-based rule engine is an excellent fit for implementing complex dynamic pricing rules.</p>"},{"location":"use-cases/dynamic-pricing.html#why-use-bonsai-for-dynamic-pricing","title":"Why Use Bonsai for Dynamic Pricing?","text":"<p>Bonsai offers several advantages for dynamic pricing:</p> <ul> <li>Complex Conditions: Pricing rules can be based on various factors</li> <li>Hierarchical Structure: Pricing rules can be organized in a hierarchical structure</li> <li>Dynamic Updates: Pricing rules can be updated without code changes</li> <li>Versioning: Changes to pricing rules can be tracked and potentially reverted</li> <li>Performance: Efficient evaluation for high-throughput scenarios</li> </ul>"},{"location":"use-cases/dynamic-pricing.html#basic-pricing-rule-implementation","title":"Basic Pricing Rule Implementation","text":"<p>Here's a simple example of implementing dynamic pricing with Bonsai:</p> <pre><code>// Create a Bonsai instance\nBonsai&lt;Context&gt; bonsai = BonsaiBuilder.builder()\n    .withBonsaiProperties(BonsaiProperties.builder().build())\n    .withEdgeStore(new InMemoryEdgeStore())\n    .withKeyTreeStore(new InMemoryKeyTreeStore())\n    .withKnotStore(new InMemoryKnotStore())\n    .build();\n\n// Create pricing knots\nKnot standardPricing = bonsai.createKnot(\n    ValuedKnotData.builder().numberValue(10.0).build(),\n    Map.of(\"description\", \"Standard pricing\")\n);\n\nKnot discountedPricing = bonsai.createKnot(\n    ValuedKnotData.builder().numberValue(8.5).build(),\n    Map.of(\"description\", \"Discounted pricing\")\n);\n\nKnot premiumPricing = bonsai.createKnot(\n    ValuedKnotData.builder().numberValue(12.0).build(),\n    Map.of(\"description\", \"Premium pricing\")\n);\n\n// Create pricing decision tree\nKnot pricingRoot = bonsai.createKnot(\n    ValuedKnotData.builder().build(),\n    Map.of(\"description\", \"Pricing decision root\")\n);\n\n// Premium pricing for high-demand times\nbonsai.addVariation(pricingRoot.getId(), Variation.builder()\n    .knotId(premiumPricing.getId())\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.request.time\")\n            .operator(Operator.IN)\n            .value(List.of(\"PEAK_MORNING\", \"PEAK_EVENING\"))\n            .build()\n    ))\n    .build());\n\n// Discounted pricing for loyal customers\nbonsai.addVariation(pricingRoot.getId(), Variation.builder()\n    .knotId(discountedPricing.getId())\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.user.loyaltyTier\")\n            .operator(Operator.GREATER_THAN_EQUAL)\n            .value(3)\n            .build()\n    ))\n    .build());\n\n// Standard pricing as default\nbonsai.addVariation(pricingRoot.getId(), Variation.builder()\n    .knotId(standardPricing.getId())\n    .filters(List.of())\n    .build());\n\n// Map to a key\nbonsai.createMapping(\"pricing.standard\", pricingRoot.getId());\n\n// Evaluate the pricing\nContext context = Context.builder()\n    .documentContext(JsonPath.parse(\"{\\\"user\\\": {\\\"loyaltyTier\\\": 4}, \\\"request\\\": {\\\"time\\\": \\\"REGULAR\\\"}}\"))\n    .build();\nKeyNode result = bonsai.evaluate(\"pricing.standard\", context);\ndouble price = result.getValue().getNumberValue(); // 8.5\n</code></pre>"},{"location":"use-cases/dynamic-pricing.html#advanced-pricing-rule-implementation","title":"Advanced Pricing Rule Implementation","text":"<p>For a more sophisticated dynamic pricing system, you can implement:</p>"},{"location":"use-cases/dynamic-pricing.html#multiple-factors","title":"Multiple Factors","text":"<p>Adjust prices based on multiple factors:</p> <pre><code>// Premium pricing for high-demand times and premium users\nbonsai.addVariation(pricingRoot.getId(), Variation.builder()\n    .knotId(premiumPricing.getId())\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.request.time\")\n            .operator(Operator.IN)\n            .value(List.of(\"PEAK_MORNING\", \"PEAK_EVENING\"))\n            .build(),\n        Filter.builder()\n            .path(\"$.user.type\")\n            .operator(Operator.EQUALS)\n            .value(\"premium\")\n            .build()\n    ))\n    .build());\n</code></pre>"},{"location":"use-cases/dynamic-pricing.html#time-based-pricing","title":"Time-Based Pricing","text":"<p>Adjust prices based on time:</p> <pre><code>// Weekend pricing\nbonsai.addVariation(pricingRoot.getId(), Variation.builder()\n    .knotId(weekendPricing.getId())\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.request.dayOfWeek\")\n            .operator(Operator.IN)\n            .value(List.of(\"SATURDAY\", \"SUNDAY\"))\n            .build()\n    ))\n    .build());\n\n// Holiday pricing\nbonsai.addVariation(pricingRoot.getId(), Variation.builder()\n    .knotId(holidayPricing.getId())\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.request.isHoliday\")\n            .operator(Operator.EQUALS)\n            .value(true)\n            .build()\n    ))\n    .build());\n</code></pre>"},{"location":"use-cases/dynamic-pricing.html#location-based-pricing","title":"Location-Based Pricing","text":"<p>Adjust prices based on location:</p> <pre><code>// Regional pricing\nbonsai.addVariation(pricingRoot.getId(), Variation.builder()\n    .knotId(highCostRegionPricing.getId())\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.request.region\")\n            .operator(Operator.IN)\n            .value(List.of(\"NYC\", \"SF\", \"LA\"))\n            .build()\n    ))\n    .build());\n</code></pre>"},{"location":"use-cases/dynamic-pricing.html#demand-based-pricing","title":"Demand-Based Pricing","text":"<p>Adjust prices based on demand:</p> <pre><code>// High demand pricing\nbonsai.addVariation(pricingRoot.getId(), Variation.builder()\n    .knotId(highDemandPricing.getId())\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.request.demandLevel\")\n            .operator(Operator.GREATER_THAN)\n            .value(0.8)\n            .build()\n    ))\n    .build());\n\n// Low demand pricing\nbonsai.addVariation(pricingRoot.getId(), Variation.builder()\n    .knotId(lowDemandPricing.getId())\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.request.demandLevel\")\n            .operator(Operator.LESS_THAN)\n            .value(0.2)\n            .build()\n    ))\n    .build());\n</code></pre>"},{"location":"use-cases/dynamic-pricing.html#customer-segment-pricing","title":"Customer Segment Pricing","text":"<p>Adjust prices based on customer segments:</p> <pre><code>// New customer pricing\nbonsai.addVariation(pricingRoot.getId(), Variation.builder()\n    .knotId(newCustomerPricing.getId())\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.user.isNew\")\n            .operator(Operator.EQUALS)\n            .value(true)\n            .build()\n    ))\n    .build());\n\n// VIP customer pricing\nbonsai.addVariation(pricingRoot.getId(), Variation.builder()\n    .knotId(vipCustomerPricing.getId())\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.user.isVIP\")\n            .operator(Operator.EQUALS)\n            .value(true)\n            .build()\n    ))\n    .build());\n</code></pre>"},{"location":"use-cases/dynamic-pricing.html#product-specific-pricing","title":"Product-Specific Pricing","text":"<p>Implement different pricing rules for different products:</p> <pre><code>// Create product-specific pricing knots\nKnot product1PricingKnot = bonsai.createKnot(\n    ValuedKnotData.builder().build(),\n    Map.of(\"description\", \"Product 1 Pricing\")\n);\n\nKnot product2PricingKnot = bonsai.createKnot(\n    ValuedKnotData.builder().build(),\n    Map.of(\"description\", \"Product 2 Pricing\")\n);\n\n// Add variations to product-specific pricing knots\n// ...\n\n// Create a map of product pricing\nKnot productPricingKnot = bonsai.createKnot(\n    MapKnotData.builder()\n        .keyMapping(Map.of(\n            \"product1\", product1PricingKnot.getId(),\n            \"product2\", product2PricingKnot.getId()\n        ))\n        .build(),\n    Map.of(\"description\", \"Product Pricing\")\n);\n\n// Map to a key\nbonsai.createMapping(\"pricing.products\", productPricingKnot.getId());\n\n// Evaluate product-specific pricing\nKeyNode result = bonsai.evaluate(\"pricing.products.product1\", context);\ndouble product1Price = result.getValue().getNumberValue();\n</code></pre>"},{"location":"use-cases/dynamic-pricing.html#price-modifiers","title":"Price Modifiers","text":"<p>Implement price modifiers that adjust a base price:</p> <pre><code>// Create price modifier knots\nKnot noModifier = bonsai.createKnot(\n    ValuedKnotData.builder().numberValue(0.0).build(),\n    Map.of(\"description\", \"No price modifier\")\n);\n\nKnot discountModifier = bonsai.createKnot(\n    ValuedKnotData.builder().numberValue(-1.5).build(),\n    Map.of(\"description\", \"Discount modifier\")\n);\n\nKnot premiumModifier = bonsai.createKnot(\n    ValuedKnotData.builder().numberValue(2.0).build(),\n    Map.of(\"description\", \"Premium modifier\")\n);\n\n// Create a price modifier decision tree\nKnot modifierRoot = bonsai.createKnot(\n    ValuedKnotData.builder().build(),\n    Map.of(\"description\", \"Price modifier decision root\")\n);\n\n// Add variations to the modifier root\n// ...\n\n// Map to a key\nbonsai.createMapping(\"pricing.modifier\", modifierRoot.getId());\n\n// Evaluate the base price and modifier\nKeyNode baseResult = bonsai.evaluate(\"pricing.standard\", context);\nKeyNode modifierResult = bonsai.evaluate(\"pricing.modifier\", context);\ndouble basePrice = baseResult.getValue().getNumberValue();\ndouble modifier = modifierResult.getValue().getNumberValue();\ndouble finalPrice = basePrice + modifier;\n</code></pre>"},{"location":"use-cases/dynamic-pricing.html#pricing-service","title":"Pricing Service","text":"<p>In a real application, you would typically implement a service layer for pricing:</p> <pre><code>@Service\npublic class PricingService {\n    private final Bonsai&lt;Context&gt; bonsai;\n\n    @Autowired\n    public PricingService(Bonsai&lt;Context&gt; bonsai) {\n        this.bonsai = bonsai;\n    }\n\n    public double getPrice(String productId, User user, RequestContext requestContext) {\n        // Create a context with user and request data\n        Map&lt;String, Object&gt; contextData = new HashMap&lt;&gt;();\n        contextData.put(\"user\", user);\n        contextData.put(\"request\", requestContext);\n        contextData.put(\"product\", productRepository.findById(productId));\n\n        Context context = Context.builder()\n            .documentContext(JsonPath.parse(contextData))\n            .build();\n\n        // Evaluate the pricing\n        try {\n            KeyNode result = bonsai.evaluate(\"pricing.products.\" + productId, context);\n            return result.getValue().getNumberValue();\n        } catch (BonsaiError e) {\n            // Handle errors (e.g., pricing rule not found)\n            return getDefaultPrice(productId);\n        }\n    }\n\n    private double getDefaultPrice(String productId) {\n        // Return a default price for the product\n        return productRepository.findById(productId).getDefaultPrice();\n    }\n}\n</code></pre>"},{"location":"use-cases/dynamic-pricing.html#pricing-rule-management-ui","title":"Pricing Rule Management UI","text":"<p>For a complete dynamic pricing system, you would typically implement a management UI that allows business users to:</p> <ul> <li>Create and manage pricing rules</li> <li>Define conditions for different prices</li> <li>Monitor pricing rule usage</li> <li>A/B test pricing rules</li> <li>Analyze the impact of pricing rules on revenue</li> </ul> <p>While implementing a UI is beyond the scope of this guide, Bonsai's API provides all the necessary operations to support such a UI.</p>"},{"location":"use-cases/dynamic-pricing.html#best-practices","title":"Best Practices","text":"<ul> <li>Use a consistent naming convention: Use a consistent naming convention for pricing rule keys</li> <li>Document pricing rules: Document the purpose and conditions of each pricing rule</li> <li>Test pricing rules: Test pricing rules with various inputs to ensure they work as expected</li> <li>Monitor pricing rule usage: Track which prices are applied in which scenarios</li> <li>Consider performance: Optimize pricing rule evaluation for high-throughput scenarios</li> <li>Implement caching: Cache pricing results to improve performance</li> <li>Handle errors gracefully: Provide sensible defaults when pricing rules cannot be evaluated</li> <li>Consider legal and ethical implications: Ensure that your dynamic pricing strategy complies with relevant laws and regulations</li> </ul>"},{"location":"use-cases/feature-flagging.html","title":"Feature Flagging System","text":"<p>Feature flags (also known as feature toggles or feature switches) are a powerful technique for modifying system behavior without changing code. Bonsai's tree-based rule engine is an excellent fit for implementing a sophisticated feature flagging system.</p>"},{"location":"use-cases/feature-flagging.html#why-use-bonsai-for-feature-flags","title":"Why Use Bonsai for Feature Flags?","text":"<p>Bonsai offers several advantages for feature flagging:</p> <ul> <li>Conditional Logic: Feature flags can be based on various factors like user attributes, environment, or time</li> <li>Hierarchical Structure: Features can be organized in a hierarchical structure</li> <li>Dynamic Updates: Feature flags can be updated without code changes or redeployment</li> <li>Versioning: Changes to feature flags can be tracked and potentially reverted</li> <li>Performance: Efficient evaluation for high-throughput scenarios</li> </ul>"},{"location":"use-cases/feature-flagging.html#basic-feature-flag-implementation","title":"Basic Feature Flag Implementation","text":"<p>Here's a simple example of implementing feature flags with Bonsai:</p> <pre><code>// Create a Bonsai instance\nBonsai&lt;Context&gt; bonsai = BonsaiBuilder.builder()\n    .withBonsaiProperties(BonsaiProperties.builder().build())\n    .withEdgeStore(new InMemoryEdgeStore())\n    .withKeyTreeStore(new InMemoryKeyTreeStore())\n    .withKnotStore(new InMemoryKnotStore())\n    .build();\n\n// Create enabled and disabled knots\nKnot enabledKnot = bonsai.createKnot(\n    ValuedKnotData.builder().booleanValue(true).build(),\n    Map.of(\"description\", \"Feature enabled\")\n);\n\nKnot disabledKnot = bonsai.createKnot(\n    ValuedKnotData.builder().booleanValue(false).build(),\n    Map.of(\"description\", \"Feature disabled\")\n);\n\n// Create a feature flag knot\nKnot newUIFeatureKnot = bonsai.createKnot(\n    ValuedKnotData.builder().build(),\n    Map.of(\"description\", \"New UI Feature Flag\")\n);\n\n// Enable for beta users\nbonsai.addVariation(newUIFeatureKnot.getId(), Variation.builder()\n    .knotId(enabledKnot.getId())\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.user.betaProgram\")\n            .operator(Operator.EQUALS)\n            .value(true)\n            .build()\n    ))\n    .build());\n\n// Default to disabled\nbonsai.addVariation(newUIFeatureKnot.getId(), Variation.builder()\n    .knotId(disabledKnot.getId())\n    .filters(List.of())\n    .build());\n\n// Map to a key\nbonsai.createMapping(\"features.newUI\", newUIFeatureKnot.getId());\n\n// Evaluate the feature flag\nContext context = Context.builder()\n    .documentContext(JsonPath.parse(\"{\\\"user\\\": {\\\"betaProgram\\\": true}}\"))\n    .build();\nKeyNode result = bonsai.evaluate(\"features.newUI\", context);\nboolean isEnabled = result.getValue().getBooleanValue(); // true\n</code></pre>"},{"location":"use-cases/feature-flagging.html#advanced-feature-flag-implementation","title":"Advanced Feature Flag Implementation","text":"<p>For a more sophisticated feature flagging system, you can implement:</p>"},{"location":"use-cases/feature-flagging.html#multiple-conditions","title":"Multiple Conditions","text":"<p>Enable features based on multiple conditions:</p> <pre><code>// Enable for beta users in specific regions\nbonsai.addVariation(newUIFeatureKnot.getId(), Variation.builder()\n    .knotId(enabledKnot.getId())\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.user.betaProgram\")\n            .operator(Operator.EQUALS)\n            .value(true)\n            .build(),\n        Filter.builder()\n            .path(\"$.user.region\")\n            .operator(Operator.IN)\n            .value(List.of(\"US-WEST\", \"EU-CENTRAL\"))\n            .build()\n    ))\n    .build());\n</code></pre>"},{"location":"use-cases/feature-flagging.html#percentage-rollouts","title":"Percentage Rollouts","text":"<p>Enable features for a percentage of users:</p> <pre><code>// Enable for 10% of users\nbonsai.addVariation(newUIFeatureKnot.getId(), Variation.builder()\n    .knotId(enabledKnot.getId())\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.user.id\")\n            .operator(Operator.MODULO)\n            .value(10)\n            .build(),\n        Filter.builder()\n            .path(\"$.user.id.modulo\")\n            .operator(Operator.LESS_THAN)\n            .value(1)\n            .build()\n    ))\n    .build());\n</code></pre>"},{"location":"use-cases/feature-flagging.html#time-based-rollouts","title":"Time-Based Rollouts","text":"<p>Enable features based on time:</p> <pre><code>// Enable during business hours\nbonsai.addVariation(newUIFeatureKnot.getId(), Variation.builder()\n    .knotId(enabledKnot.getId())\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.request.time.hour\")\n            .operator(Operator.GREATER_THAN_EQUAL)\n            .value(9)\n            .build(),\n        Filter.builder()\n            .path(\"$.request.time.hour\")\n            .operator(Operator.LESS_THAN)\n            .value(17)\n            .build()\n    ))\n    .build());\n</code></pre>"},{"location":"use-cases/feature-flagging.html#feature-dependencies","title":"Feature Dependencies","text":"<p>Enable features based on other features:</p> <pre><code>// Enable if another feature is enabled\nbonsai.addVariation(newUIFeatureKnot.getId(), Variation.builder()\n    .knotId(enabledKnot.getId())\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.features.parentFeature\")\n            .operator(Operator.EQUALS)\n            .value(true)\n            .build()\n    ))\n    .build());\n</code></pre>"},{"location":"use-cases/feature-flagging.html#feature-configuration","title":"Feature Configuration","text":"<p>Provide configuration for features:</p> <pre><code>// Create configuration knots\nKnot defaultConfigKnot = bonsai.createKnot(\n    ValuedKnotData.builder().jsonValue(\"{\\\"theme\\\":\\\"light\\\",\\\"layout\\\":\\\"standard\\\"}\").build(),\n    Map.of(\"description\", \"Default UI configuration\")\n);\n\nKnot betaConfigKnot = bonsai.createKnot(\n    ValuedKnotData.builder().jsonValue(\"{\\\"theme\\\":\\\"dark\\\",\\\"layout\\\":\\\"compact\\\"}\").build(),\n    Map.of(\"description\", \"Beta UI configuration\")\n);\n\n// Create a configuration knot\nKnot uiConfigKnot = bonsai.createKnot(\n    ValuedKnotData.builder().build(),\n    Map.of(\"description\", \"UI Configuration\")\n);\n\n// Beta configuration for beta users\nbonsai.addVariation(uiConfigKnot.getId(), Variation.builder()\n    .knotId(betaConfigKnot.getId())\n    .filters(List.of(\n        Filter.builder()\n            .path(\"$.user.betaProgram\")\n            .operator(Operator.EQUALS)\n            .value(true)\n            .build()\n    ))\n    .build());\n\n// Default configuration\nbonsai.addVariation(uiConfigKnot.getId(), Variation.builder()\n    .knotId(defaultConfigKnot.getId())\n    .filters(List.of())\n    .build());\n\n// Map to a key\nbonsai.createMapping(\"features.uiConfig\", uiConfigKnot.getId());\n</code></pre>"},{"location":"use-cases/feature-flagging.html#hierarchical-feature-flags","title":"Hierarchical Feature Flags","text":"<p>Organize feature flags in a hierarchical structure:</p> <pre><code>// Create a map of feature flags\nKnot featureFlagsKnot = bonsai.createKnot(\n    MapKnotData.builder()\n        .keyMapping(Map.of(\n            \"newUI\", newUIFeatureKnot.getId(),\n            \"newCheckout\", checkoutFeatureKnot.getId(),\n            \"newSearch\", searchFeatureKnot.getId()\n        ))\n        .build(),\n    Map.of(\"description\", \"Feature Flags\")\n);\n\n// Map to a key\nbonsai.createMapping(\"features\", featureFlagsKnot.getId());\n\n// Evaluate all feature flags\nKeyNode result = bonsai.evaluate(\"features\", context);\nMap&lt;String, KeyNode&gt; featureFlags = result.getKeyNodeMap();\nboolean newUIEnabled = featureFlags.get(\"newUI\").getValue().getBooleanValue();\nboolean newCheckoutEnabled = featureFlags.get(\"newCheckout\").getValue().getBooleanValue();\nboolean newSearchEnabled = featureFlags.get(\"newSearch\").getValue().getBooleanValue();\n</code></pre>"},{"location":"use-cases/feature-flagging.html#feature-flag-service","title":"Feature Flag Service","text":"<p>In a real application, you would typically implement a service layer for feature flags:</p> <pre><code>@Service\npublic class FeatureFlagService {\n    private final Bonsai&lt;Context&gt; bonsai;\n\n    @Autowired\n    public FeatureFlagService(Bonsai&lt;Context&gt; bonsai) {\n        this.bonsai = bonsai;\n    }\n\n    public boolean isFeatureEnabled(String featureKey, User user) {\n        // Create a context with user data\n        Context context = Context.builder()\n            .documentContext(JsonPath.parse(user))\n            .build();\n\n        // Evaluate the feature flag\n        try {\n            KeyNode result = bonsai.evaluate(\"features.\" + featureKey, context);\n            return result.getValue().getBooleanValue();\n        } catch (BonsaiError e) {\n            // Handle errors (e.g., feature flag not found)\n            return false;\n        }\n    }\n\n    public &lt;T&gt; T getFeatureConfig(String featureKey, User user, Class&lt;T&gt; configClass) {\n        // Create a context with user data\n        Context context = Context.builder()\n            .documentContext(JsonPath.parse(user))\n            .build();\n\n        // Evaluate the feature configuration\n        try {\n            KeyNode result = bonsai.evaluate(\"features.\" + featureKey + \".config\", context);\n            String json = result.getValue().getJsonValue();\n            return new ObjectMapper().readValue(json, configClass);\n        } catch (Exception e) {\n            // Handle errors (e.g., feature config not found, invalid JSON)\n            return null;\n        }\n    }\n}\n</code></pre>"},{"location":"use-cases/feature-flagging.html#feature-flag-management-ui","title":"Feature Flag Management UI","text":"<p>For a complete feature flagging system, you would typically implement a management UI that allows non-technical users to:</p> <ul> <li>Create and manage feature flags</li> <li>Define conditions for enabling features</li> <li>Monitor feature flag usage</li> <li>A/B test features</li> <li>Gradually roll out features</li> </ul> <p>While implementing a UI is beyond the scope of this guide, Bonsai's API provides all the necessary operations to support such a UI.</p>"},{"location":"use-cases/feature-flagging.html#best-practices","title":"Best Practices","text":"<ul> <li>Use a consistent naming convention: Use a consistent naming convention for feature flag keys</li> <li>Document feature flags: Document the purpose and conditions of each feature flag</li> <li>Clean up old feature flags: Remove feature flags that are no longer needed</li> <li>Test feature flags: Test both enabled and disabled states of feature flags</li> <li>Monitor feature flag usage: Track which features are enabled for which users</li> <li>Consider performance: Optimize feature flag evaluation for high-throughput scenarios</li> <li>Implement caching: Cache feature flag results to improve performance</li> <li>Handle errors gracefully: Provide sensible defaults when feature flags cannot be evaluated</li> </ul>"}]}